// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.postgres.sql

package postgresdb

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const addNarInfoReference = `-- name: AddNarInfoReference :exec
INSERT INTO narinfo_references (
    narinfo_id, reference
) VALUES (
    $1, $2
)
ON CONFLICT (narinfo_id, reference) DO NOTHING
`

type AddNarInfoReferenceParams struct {
	NarInfoID int64
	Reference string
}

// AddNarInfoReference
//
//	INSERT INTO narinfo_references (
//	    narinfo_id, reference
//	) VALUES (
//	    $1, $2
//	)
//	ON CONFLICT (narinfo_id, reference) DO NOTHING
func (q *Queries) AddNarInfoReference(ctx context.Context, arg AddNarInfoReferenceParams) error {
	_, err := q.db.ExecContext(ctx, addNarInfoReference, arg.NarInfoID, arg.Reference)
	return err
}

const addNarInfoReferences = `-- name: AddNarInfoReferences :exec
INSERT INTO narinfo_references (
    narinfo_id, reference
)
SELECT $1, unnest($2::text[]) ON CONFLICT (narinfo_id, reference) DO NOTHING
`

type AddNarInfoReferencesParams struct {
	NarInfoID int64
	Reference []string
}

// @bulk-for AddNarInfoReference
//
//	INSERT INTO narinfo_references (
//	    narinfo_id, reference
//	)
//	SELECT $1, unnest($2::text[]) ON CONFLICT (narinfo_id, reference) DO NOTHING
func (q *Queries) AddNarInfoReferences(ctx context.Context, arg AddNarInfoReferencesParams) error {
	_, err := q.db.ExecContext(ctx, addNarInfoReferences, arg.NarInfoID, pq.Array(arg.Reference))
	return err
}

const addNarInfoSignature = `-- name: AddNarInfoSignature :exec
INSERT INTO narinfo_signatures (
    narinfo_id, signature
) VALUES (
    $1, $2
)
ON CONFLICT (narinfo_id, signature) DO NOTHING
`

type AddNarInfoSignatureParams struct {
	NarInfoID int64
	Signature string
}

// AddNarInfoSignature
//
//	INSERT INTO narinfo_signatures (
//	    narinfo_id, signature
//	) VALUES (
//	    $1, $2
//	)
//	ON CONFLICT (narinfo_id, signature) DO NOTHING
func (q *Queries) AddNarInfoSignature(ctx context.Context, arg AddNarInfoSignatureParams) error {
	_, err := q.db.ExecContext(ctx, addNarInfoSignature, arg.NarInfoID, arg.Signature)
	return err
}

const addNarInfoSignatures = `-- name: AddNarInfoSignatures :exec
INSERT INTO narinfo_signatures (
    narinfo_id, signature
)
SELECT $1, unnest($2::text[]) ON CONFLICT (narinfo_id, signature) DO NOTHING
`

type AddNarInfoSignaturesParams struct {
	NarInfoID int64
	Signature []string
}

// @bulk-for AddNarInfoSignature
//
//	INSERT INTO narinfo_signatures (
//	    narinfo_id, signature
//	)
//	SELECT $1, unnest($2::text[]) ON CONFLICT (narinfo_id, signature) DO NOTHING
func (q *Queries) AddNarInfoSignatures(ctx context.Context, arg AddNarInfoSignaturesParams) error {
	_, err := q.db.ExecContext(ctx, addNarInfoSignatures, arg.NarInfoID, pq.Array(arg.Signature))
	return err
}

const createChunk = `-- name: CreateChunk :one
INSERT INTO chunks (
    hash, size, compressed_size
) VALUES (
    $1, $2, $3
)
ON CONFLICT(hash) DO UPDATE SET
    updated_at = CURRENT_TIMESTAMP
RETURNING id, hash, size, compressed_size, created_at, updated_at
`

type CreateChunkParams struct {
	Hash           string
	Size           uint32
	CompressedSize uint32
}

// CreateChunk
//
//	INSERT INTO chunks (
//	    hash, size, compressed_size
//	) VALUES (
//	    $1, $2, $3
//	)
//	ON CONFLICT(hash) DO UPDATE SET
//	    updated_at = CURRENT_TIMESTAMP
//	RETURNING id, hash, size, compressed_size, created_at, updated_at
func (q *Queries) CreateChunk(ctx context.Context, arg CreateChunkParams) (Chunk, error) {
	row := q.db.QueryRowContext(ctx, createChunk, arg.Hash, arg.Size, arg.CompressedSize)
	var i Chunk
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Size,
		&i.CompressedSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createConfig = `-- name: CreateConfig :one
INSERT INTO config (
    key, value
) VALUES (
    $1, $2
)
RETURNING id, key, value, created_at, updated_at
`

type CreateConfigParams struct {
	Key   string
	Value string
}

// CreateConfig
//
//	INSERT INTO config (
//	    key, value
//	) VALUES (
//	    $1, $2
//	)
//	RETURNING id, key, value, created_at, updated_at
func (q *Queries) CreateConfig(ctx context.Context, arg CreateConfigParams) (Config, error) {
	row := q.db.QueryRowContext(ctx, createConfig, arg.Key, arg.Value)
	var i Config
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNarFile = `-- name: CreateNarFile :one
INSERT INTO nar_files (
    hash, compression, query, file_size, total_chunks
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT (hash, compression, query) DO UPDATE SET
    updated_at = EXCLUDED.updated_at
RETURNING
    id,
    hash,
    compression,
    file_size,
    query,
    created_at,
    updated_at,
    last_accessed_at,
    total_chunks,
    chunking_started_at
`

type CreateNarFileParams struct {
	Hash        string
	Compression string
	Query       string
	FileSize    uint64
	TotalChunks int64
}

// CreateNarFile
//
//	INSERT INTO nar_files (
//	    hash, compression, query, file_size, total_chunks
//	) VALUES (
//	    $1, $2, $3, $4, $5
//	)
//	ON CONFLICT (hash, compression, query) DO UPDATE SET
//	    updated_at = EXCLUDED.updated_at
//	RETURNING
//	    id,
//	    hash,
//	    compression,
//	    file_size,
//	    query,
//	    created_at,
//	    updated_at,
//	    last_accessed_at,
//	    total_chunks,
//	    chunking_started_at
func (q *Queries) CreateNarFile(ctx context.Context, arg CreateNarFileParams) (NarFile, error) {
	row := q.db.QueryRowContext(ctx, createNarFile,
		arg.Hash,
		arg.Compression,
		arg.Query,
		arg.FileSize,
		arg.TotalChunks,
	)
	var i NarFile
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Compression,
		&i.FileSize,
		&i.Query,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAccessedAt,
		&i.TotalChunks,
		&i.ChunkingStartedAt,
	)
	return i, err
}

const createNarInfo = `-- name: CreateNarInfo :one
INSERT INTO narinfos (
    hash, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, system, ca
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
ON CONFLICT (hash) DO UPDATE SET
    store_path = EXCLUDED.store_path,
    url = EXCLUDED.url,
    compression = EXCLUDED.compression,
    file_hash = EXCLUDED.file_hash,
    file_size = EXCLUDED.file_size,
    nar_hash = EXCLUDED.nar_hash,
    nar_size = EXCLUDED.nar_size,
    deriver = EXCLUDED.deriver,
    system = EXCLUDED.system,
    ca = EXCLUDED.ca,
    updated_at = CURRENT_TIMESTAMP
WHERE narinfos.url IS NULL
RETURNING id, hash, created_at, updated_at, last_accessed_at, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, system, ca
`

type CreateNarInfoParams struct {
	Hash        string
	StorePath   sql.NullString
	URL         sql.NullString
	Compression sql.NullString
	FileHash    sql.NullString
	FileSize    sql.NullInt64
	NarHash     sql.NullString
	NarSize     sql.NullInt64
	Deriver     sql.NullString
	System      sql.NullString
	Ca          sql.NullString
}

// CreateNarInfo
//
//	INSERT INTO narinfos (
//	    hash, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, system, ca
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
//	)
//	ON CONFLICT (hash) DO UPDATE SET
//	    store_path = EXCLUDED.store_path,
//	    url = EXCLUDED.url,
//	    compression = EXCLUDED.compression,
//	    file_hash = EXCLUDED.file_hash,
//	    file_size = EXCLUDED.file_size,
//	    nar_hash = EXCLUDED.nar_hash,
//	    nar_size = EXCLUDED.nar_size,
//	    deriver = EXCLUDED.deriver,
//	    system = EXCLUDED.system,
//	    ca = EXCLUDED.ca,
//	    updated_at = CURRENT_TIMESTAMP
//	WHERE narinfos.url IS NULL
//	RETURNING id, hash, created_at, updated_at, last_accessed_at, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, system, ca
func (q *Queries) CreateNarInfo(ctx context.Context, arg CreateNarInfoParams) (NarInfo, error) {
	row := q.db.QueryRowContext(ctx, createNarInfo,
		arg.Hash,
		arg.StorePath,
		arg.URL,
		arg.Compression,
		arg.FileHash,
		arg.FileSize,
		arg.NarHash,
		arg.NarSize,
		arg.Deriver,
		arg.System,
		arg.Ca,
	)
	var i NarInfo
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAccessedAt,
		&i.StorePath,
		&i.URL,
		&i.Compression,
		&i.FileHash,
		&i.FileSize,
		&i.NarHash,
		&i.NarSize,
		&i.Deriver,
		&i.System,
		&i.Ca,
	)
	return i, err
}

const deleteChunkByID = `-- name: DeleteChunkByID :exec
DELETE FROM chunks
WHERE id = $1
`

// DeleteChunkByID
//
//	DELETE FROM chunks
//	WHERE id = $1
func (q *Queries) DeleteChunkByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteChunkByID, id)
	return err
}

const deleteNarFileByHash = `-- name: DeleteNarFileByHash :execrows
DELETE FROM nar_files
WHERE hash = $1 AND compression = $2 AND query = $3
`

type DeleteNarFileByHashParams struct {
	Hash        string
	Compression string
	Query       string
}

// DeleteNarFileByHash
//
//	DELETE FROM nar_files
//	WHERE hash = $1 AND compression = $2 AND query = $3
func (q *Queries) DeleteNarFileByHash(ctx context.Context, arg DeleteNarFileByHashParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteNarFileByHash, arg.Hash, arg.Compression, arg.Query)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteNarFileByID = `-- name: DeleteNarFileByID :execrows
DELETE FROM nar_files
WHERE id = $1
`

// DeleteNarFileByID
//
//	DELETE FROM nar_files
//	WHERE id = $1
func (q *Queries) DeleteNarFileByID(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteNarFileByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteNarFileChunksByNarFileID = `-- name: DeleteNarFileChunksByNarFileID :exec
DELETE FROM nar_file_chunks
WHERE nar_file_id = $1
`

// DeleteNarFileChunksByNarFileID
//
//	DELETE FROM nar_file_chunks
//	WHERE nar_file_id = $1
func (q *Queries) DeleteNarFileChunksByNarFileID(ctx context.Context, narFileID int64) error {
	_, err := q.db.ExecContext(ctx, deleteNarFileChunksByNarFileID, narFileID)
	return err
}

const deleteNarInfoByHash = `-- name: DeleteNarInfoByHash :execrows
DELETE FROM narinfos
WHERE hash = $1
`

// DeleteNarInfoByHash
//
//	DELETE FROM narinfos
//	WHERE hash = $1
func (q *Queries) DeleteNarInfoByHash(ctx context.Context, hash string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteNarInfoByHash, hash)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteNarInfoByID = `-- name: DeleteNarInfoByID :execrows
DELETE FROM narinfos
WHERE id = $1
`

// DeleteNarInfoByID
//
//	DELETE FROM narinfos
//	WHERE id = $1
func (q *Queries) DeleteNarInfoByID(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteNarInfoByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteOrphanedNarFiles = `-- name: DeleteOrphanedNarFiles :execrows
DELETE FROM nar_files
WHERE id NOT IN (
    SELECT DISTINCT nar_file_id
    FROM narinfo_nar_files
)
`

// DeleteOrphanedNarFiles
//
//	DELETE FROM nar_files
//	WHERE id NOT IN (
//	    SELECT DISTINCT nar_file_id
//	    FROM narinfo_nar_files
//	)
func (q *Queries) DeleteOrphanedNarFiles(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteOrphanedNarFiles)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteOrphanedNarInfos = `-- name: DeleteOrphanedNarInfos :execrows
DELETE FROM narinfos
WHERE id NOT IN (
    SELECT DISTINCT narinfo_id
    FROM narinfo_nar_files
)
`

// DeleteOrphanedNarInfos
//
//	DELETE FROM narinfos
//	WHERE id NOT IN (
//	    SELECT DISTINCT narinfo_id
//	    FROM narinfo_nar_files
//	)
func (q *Queries) DeleteOrphanedNarInfos(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteOrphanedNarInfos)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getChunkByHash = `-- name: GetChunkByHash :one
SELECT id, hash, size, compressed_size, created_at, updated_at
FROM chunks
WHERE hash = $1
`

// GetChunkByHash
//
//	SELECT id, hash, size, compressed_size, created_at, updated_at
//	FROM chunks
//	WHERE hash = $1
func (q *Queries) GetChunkByHash(ctx context.Context, hash string) (Chunk, error) {
	row := q.db.QueryRowContext(ctx, getChunkByHash, hash)
	var i Chunk
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Size,
		&i.CompressedSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChunkByID = `-- name: GetChunkByID :one
SELECT id, hash, size, compressed_size, created_at, updated_at
FROM chunks
WHERE id = $1
`

// GetChunkByID
//
//	SELECT id, hash, size, compressed_size, created_at, updated_at
//	FROM chunks
//	WHERE id = $1
func (q *Queries) GetChunkByID(ctx context.Context, id int64) (Chunk, error) {
	row := q.db.QueryRowContext(ctx, getChunkByID, id)
	var i Chunk
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Size,
		&i.CompressedSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChunkByNarFileIDAndIndex = `-- name: GetChunkByNarFileIDAndIndex :one
SELECT c.id, c.hash, c.size, c.created_at, c.updated_at
FROM chunks c
INNER JOIN nar_file_chunks nfc ON c.id = nfc.chunk_id
WHERE nfc.nar_file_id = $1 AND nfc.chunk_index = $2
`

type GetChunkByNarFileIDAndIndexParams struct {
	NarFileID  int64
	ChunkIndex int64
}

type GetChunkByNarFileIDAndIndexRow struct {
	ID        int64
	Hash      string
	Size      uint32
	CreatedAt time.Time
	UpdatedAt sql.NullTime
}

// GetChunkByNarFileIDAndIndex
//
//	SELECT c.id, c.hash, c.size, c.created_at, c.updated_at
//	FROM chunks c
//	INNER JOIN nar_file_chunks nfc ON c.id = nfc.chunk_id
//	WHERE nfc.nar_file_id = $1 AND nfc.chunk_index = $2
func (q *Queries) GetChunkByNarFileIDAndIndex(ctx context.Context, arg GetChunkByNarFileIDAndIndexParams) (GetChunkByNarFileIDAndIndexRow, error) {
	row := q.db.QueryRowContext(ctx, getChunkByNarFileIDAndIndex, arg.NarFileID, arg.ChunkIndex)
	var i GetChunkByNarFileIDAndIndexRow
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Size,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChunkCount = `-- name: GetChunkCount :one
SELECT CAST(COUNT(*) AS BIGINT) AS count
FROM chunks
`

// GetChunkCount
//
//	SELECT CAST(COUNT(*) AS BIGINT) AS count
//	FROM chunks
func (q *Queries) GetChunkCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getChunkCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getChunksByNarFileID = `-- name: GetChunksByNarFileID :many
SELECT c.id, c.hash, c.size, c.compressed_size, c.created_at, c.updated_at
FROM chunks c
INNER JOIN nar_file_chunks nfc ON c.id = nfc.chunk_id
WHERE nfc.nar_file_id = $1
ORDER BY nfc.chunk_index
`

// GetChunksByNarFileID
//
//	SELECT c.id, c.hash, c.size, c.compressed_size, c.created_at, c.updated_at
//	FROM chunks c
//	INNER JOIN nar_file_chunks nfc ON c.id = nfc.chunk_id
//	WHERE nfc.nar_file_id = $1
//	ORDER BY nfc.chunk_index
func (q *Queries) GetChunksByNarFileID(ctx context.Context, narFileID int64) ([]Chunk, error) {
	rows, err := q.db.QueryContext(ctx, getChunksByNarFileID, narFileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chunk
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.ID,
			&i.Hash,
			&i.Size,
			&i.CompressedSize,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompressedNarInfos = `-- name: GetCompressedNarInfos :many
SELECT id, hash, created_at, updated_at, last_accessed_at, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, system, ca
FROM narinfos
WHERE compression NOT IN ('', 'none')
ORDER BY id
LIMIT $1 OFFSET $2
`

type GetCompressedNarInfosParams struct {
	Limit  int32
	Offset int32
}

// GetCompressedNarInfos
//
//	SELECT id, hash, created_at, updated_at, last_accessed_at, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, system, ca
//	FROM narinfos
//	WHERE compression NOT IN ('', 'none')
//	ORDER BY id
//	LIMIT $1 OFFSET $2
func (q *Queries) GetCompressedNarInfos(ctx context.Context, arg GetCompressedNarInfosParams) ([]NarInfo, error) {
	rows, err := q.db.QueryContext(ctx, getCompressedNarInfos, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NarInfo
	for rows.Next() {
		var i NarInfo
		if err := rows.Scan(
			&i.ID,
			&i.Hash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastAccessedAt,
			&i.StorePath,
			&i.URL,
			&i.Compression,
			&i.FileHash,
			&i.FileSize,
			&i.NarHash,
			&i.NarSize,
			&i.Deriver,
			&i.System,
			&i.Ca,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConfigByID = `-- name: GetConfigByID :one
SELECT id, key, value, created_at, updated_at
FROM config
WHERE id = $1
`

// GetConfigByID
//
//	SELECT id, key, value, created_at, updated_at
//	FROM config
//	WHERE id = $1
func (q *Queries) GetConfigByID(ctx context.Context, id int64) (Config, error) {
	row := q.db.QueryRowContext(ctx, getConfigByID, id)
	var i Config
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConfigByKey = `-- name: GetConfigByKey :one
SELECT id, key, value, created_at, updated_at
FROM config
WHERE key = $1
`

// GetConfigByKey
//
//	SELECT id, key, value, created_at, updated_at
//	FROM config
//	WHERE key = $1
func (q *Queries) GetConfigByKey(ctx context.Context, key string) (Config, error) {
	row := q.db.QueryRowContext(ctx, getConfigByKey, key)
	var i Config
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeastUsedNarFiles = `-- name: GetLeastUsedNarFiles :many
SELECT n1.id, n1.hash, n1.compression, n1.file_size, n1.query, n1.created_at, n1.updated_at, n1.last_accessed_at
FROM nar_files n1
WHERE (
    SELECT SUM(n2.file_size)
    FROM nar_files n2
    WHERE n2.last_accessed_at < n1.last_accessed_at
       OR (n2.last_accessed_at = n1.last_accessed_at AND n2.id <= n1.id)
) <= $1
`

type GetLeastUsedNarFilesRow struct {
	ID             int64
	Hash           string
	Compression    string
	FileSize       uint64
	Query          string
	CreatedAt      time.Time
	UpdatedAt      sql.NullTime
	LastAccessedAt sql.NullTime
}

// NOTE: This query uses a correlated subquery which is not optimal for performance.
// The ideal implementation would use a window function (SUM OVER), but sqlc v1.30.0
// does not properly support filtering on window function results in subqueries.
//
//	SELECT n1.id, n1.hash, n1.compression, n1.file_size, n1.query, n1.created_at, n1.updated_at, n1.last_accessed_at
//	FROM nar_files n1
//	WHERE (
//	    SELECT SUM(n2.file_size)
//	    FROM nar_files n2
//	    WHERE n2.last_accessed_at < n1.last_accessed_at
//	       OR (n2.last_accessed_at = n1.last_accessed_at AND n2.id <= n1.id)
//	) <= $1
func (q *Queries) GetLeastUsedNarFiles(ctx context.Context, fileSize uint64) ([]GetLeastUsedNarFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, getLeastUsedNarFiles, fileSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeastUsedNarFilesRow
	for rows.Next() {
		var i GetLeastUsedNarFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.Hash,
			&i.Compression,
			&i.FileSize,
			&i.Query,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastAccessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeastUsedNarInfos = `-- name: GetLeastUsedNarInfos :many
SELECT ni1.id, ni1.hash, ni1.created_at, ni1.updated_at, ni1.last_accessed_at, ni1.store_path, ni1.url, ni1.compression, ni1.file_hash, ni1.file_size, ni1.nar_hash, ni1.nar_size, ni1.deriver, ni1.system, ni1.ca
FROM narinfos ni1
WHERE (
    SELECT COALESCE(SUM(nf.file_size), 0)
    FROM nar_files nf
    WHERE nf.id IN (
        SELECT DISTINCT nnf.nar_file_id
        FROM narinfo_nar_files nnf
        INNER JOIN narinfos ni2 ON nnf.narinfo_id = ni2.id
        WHERE ni2.last_accessed_at < ni1.last_accessed_at
            OR (ni2.last_accessed_at = ni1.last_accessed_at AND ni2.id <= ni1.id)
    )
) <= $1
`

// NOTE: This query uses a correlated subquery which is not optimal for performance.
// The ideal implementation would use a window function (SUM OVER), but sqlc v1.30.0
// does not properly support filtering on window function results in subqueries.
// Gets the least-used narinfos up to a certain total file size (accounting for their nar_files).
//
//	SELECT ni1.id, ni1.hash, ni1.created_at, ni1.updated_at, ni1.last_accessed_at, ni1.store_path, ni1.url, ni1.compression, ni1.file_hash, ni1.file_size, ni1.nar_hash, ni1.nar_size, ni1.deriver, ni1.system, ni1.ca
//	FROM narinfos ni1
//	WHERE (
//	    SELECT COALESCE(SUM(nf.file_size), 0)
//	    FROM nar_files nf
//	    WHERE nf.id IN (
//	        SELECT DISTINCT nnf.nar_file_id
//	        FROM narinfo_nar_files nnf
//	        INNER JOIN narinfos ni2 ON nnf.narinfo_id = ni2.id
//	        WHERE ni2.last_accessed_at < ni1.last_accessed_at
//	            OR (ni2.last_accessed_at = ni1.last_accessed_at AND ni2.id <= ni1.id)
//	    )
//	) <= $1
func (q *Queries) GetLeastUsedNarInfos(ctx context.Context, fileSize uint64) ([]NarInfo, error) {
	rows, err := q.db.QueryContext(ctx, getLeastUsedNarInfos, fileSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NarInfo
	for rows.Next() {
		var i NarInfo
		if err := rows.Scan(
			&i.ID,
			&i.Hash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastAccessedAt,
			&i.StorePath,
			&i.URL,
			&i.Compression,
			&i.FileHash,
			&i.FileSize,
			&i.NarHash,
			&i.NarSize,
			&i.Deriver,
			&i.System,
			&i.Ca,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMigratedNarInfoHashes = `-- name: GetMigratedNarInfoHashes :many
SELECT hash
FROM narinfos
WHERE url IS NOT NULL
`

// Get all narinfo hashes that have a URL (migrated).
//
//	SELECT hash
//	FROM narinfos
//	WHERE url IS NOT NULL
func (q *Queries) GetMigratedNarInfoHashes(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getMigratedNarInfoHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var hash string
		if err := rows.Scan(&hash); err != nil {
			return nil, err
		}
		items = append(items, hash)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMigratedNarInfoHashesPaginated = `-- name: GetMigratedNarInfoHashesPaginated :many
SELECT hash
FROM narinfos
WHERE url IS NOT NULL
ORDER BY hash
LIMIT $1 OFFSET $2
`

type GetMigratedNarInfoHashesPaginatedParams struct {
	Limit  int32
	Offset int32
}

// Get migrated narinfo hashes with pagination support.
//
//	SELECT hash
//	FROM narinfos
//	WHERE url IS NOT NULL
//	ORDER BY hash
//	LIMIT $1 OFFSET $2
func (q *Queries) GetMigratedNarInfoHashesPaginated(ctx context.Context, arg GetMigratedNarInfoHashesPaginatedParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getMigratedNarInfoHashesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var hash string
		if err := rows.Scan(&hash); err != nil {
			return nil, err
		}
		items = append(items, hash)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNarFileByHashAndCompressionAndQuery = `-- name: GetNarFileByHashAndCompressionAndQuery :one
SELECT id, hash, compression, file_size, query, created_at, updated_at, last_accessed_at, total_chunks, chunking_started_at
FROM nar_files
WHERE hash = $1 AND compression = $2 AND query = $3
`

type GetNarFileByHashAndCompressionAndQueryParams struct {
	Hash        string
	Compression string
	Query       string
}

// GetNarFileByHashAndCompressionAndQuery
//
//	SELECT id, hash, compression, file_size, query, created_at, updated_at, last_accessed_at, total_chunks, chunking_started_at
//	FROM nar_files
//	WHERE hash = $1 AND compression = $2 AND query = $3
func (q *Queries) GetNarFileByHashAndCompressionAndQuery(ctx context.Context, arg GetNarFileByHashAndCompressionAndQueryParams) (NarFile, error) {
	row := q.db.QueryRowContext(ctx, getNarFileByHashAndCompressionAndQuery, arg.Hash, arg.Compression, arg.Query)
	var i NarFile
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Compression,
		&i.FileSize,
		&i.Query,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAccessedAt,
		&i.TotalChunks,
		&i.ChunkingStartedAt,
	)
	return i, err
}

const getNarFileByID = `-- name: GetNarFileByID :one
SELECT id, hash, compression, file_size, query, created_at, updated_at, last_accessed_at, total_chunks, chunking_started_at
FROM nar_files
WHERE id = $1
`

// GetNarFileByID
//
//	SELECT id, hash, compression, file_size, query, created_at, updated_at, last_accessed_at, total_chunks, chunking_started_at
//	FROM nar_files
//	WHERE id = $1
func (q *Queries) GetNarFileByID(ctx context.Context, id int64) (NarFile, error) {
	row := q.db.QueryRowContext(ctx, getNarFileByID, id)
	var i NarFile
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Compression,
		&i.FileSize,
		&i.Query,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAccessedAt,
		&i.TotalChunks,
		&i.ChunkingStartedAt,
	)
	return i, err
}

const getNarFileByNarInfoID = `-- name: GetNarFileByNarInfoID :one
SELECT nf.id, nf.hash, nf.compression, nf.file_size, nf.query, nf.created_at, nf.updated_at, nf.last_accessed_at
FROM nar_files nf
INNER JOIN narinfo_nar_files nnf ON nf.id = nnf.nar_file_id
WHERE nnf.narinfo_id = $1
`

type GetNarFileByNarInfoIDRow struct {
	ID             int64
	Hash           string
	Compression    string
	FileSize       uint64
	Query          string
	CreatedAt      time.Time
	UpdatedAt      sql.NullTime
	LastAccessedAt sql.NullTime
}

// GetNarFileByNarInfoID
//
//	SELECT nf.id, nf.hash, nf.compression, nf.file_size, nf.query, nf.created_at, nf.updated_at, nf.last_accessed_at
//	FROM nar_files nf
//	INNER JOIN narinfo_nar_files nnf ON nf.id = nnf.nar_file_id
//	WHERE nnf.narinfo_id = $1
func (q *Queries) GetNarFileByNarInfoID(ctx context.Context, narinfoID int64) (GetNarFileByNarInfoIDRow, error) {
	row := q.db.QueryRowContext(ctx, getNarFileByNarInfoID, narinfoID)
	var i GetNarFileByNarInfoIDRow
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Compression,
		&i.FileSize,
		&i.Query,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAccessedAt,
	)
	return i, err
}

const getNarFileCount = `-- name: GetNarFileCount :one
SELECT CAST(COUNT(*) AS BIGINT) AS count
FROM nar_files
`

// GetNarFileCount
//
//	SELECT CAST(COUNT(*) AS BIGINT) AS count
//	FROM nar_files
func (q *Queries) GetNarFileCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNarFileCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNarFilesToChunk = `-- name: GetNarFilesToChunk :many
SELECT id, hash, compression, query, file_size
FROM nar_files
WHERE total_chunks = 0
ORDER BY id
`

type GetNarFilesToChunkRow struct {
	ID          int64
	Hash        string
	Compression string
	Query       string
	FileSize    uint64
}

// Get all NAR files that are not yet chunked.
//
//	SELECT id, hash, compression, query, file_size
//	FROM nar_files
//	WHERE total_chunks = 0
//	ORDER BY id
func (q *Queries) GetNarFilesToChunk(ctx context.Context) ([]GetNarFilesToChunkRow, error) {
	rows, err := q.db.QueryContext(ctx, getNarFilesToChunk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNarFilesToChunkRow
	for rows.Next() {
		var i GetNarFilesToChunkRow
		if err := rows.Scan(
			&i.ID,
			&i.Hash,
			&i.Compression,
			&i.Query,
			&i.FileSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNarFilesToChunkCount = `-- name: GetNarFilesToChunkCount :one
SELECT COUNT(*)
FROM nar_files
WHERE total_chunks = 0
`

// Get the count of NAR files that are not yet chunked.
//
//	SELECT COUNT(*)
//	FROM nar_files
//	WHERE total_chunks = 0
func (q *Queries) GetNarFilesToChunkCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNarFilesToChunkCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNarInfoByHash = `-- name: GetNarInfoByHash :one
SELECT id, hash, created_at, updated_at, last_accessed_at, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, system, ca
FROM narinfos
WHERE hash = $1
`

// GetNarInfoByHash
//
//	SELECT id, hash, created_at, updated_at, last_accessed_at, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, system, ca
//	FROM narinfos
//	WHERE hash = $1
func (q *Queries) GetNarInfoByHash(ctx context.Context, hash string) (NarInfo, error) {
	row := q.db.QueryRowContext(ctx, getNarInfoByHash, hash)
	var i NarInfo
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAccessedAt,
		&i.StorePath,
		&i.URL,
		&i.Compression,
		&i.FileHash,
		&i.FileSize,
		&i.NarHash,
		&i.NarSize,
		&i.Deriver,
		&i.System,
		&i.Ca,
	)
	return i, err
}

const getNarInfoByID = `-- name: GetNarInfoByID :one
SELECT id, hash, created_at, updated_at, last_accessed_at, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, system, ca
FROM narinfos
WHERE id = $1
`

// GetNarInfoByID
//
//	SELECT id, hash, created_at, updated_at, last_accessed_at, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, system, ca
//	FROM narinfos
//	WHERE id = $1
func (q *Queries) GetNarInfoByID(ctx context.Context, id int64) (NarInfo, error) {
	row := q.db.QueryRowContext(ctx, getNarInfoByID, id)
	var i NarInfo
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAccessedAt,
		&i.StorePath,
		&i.URL,
		&i.Compression,
		&i.FileHash,
		&i.FileSize,
		&i.NarHash,
		&i.NarSize,
		&i.Deriver,
		&i.System,
		&i.Ca,
	)
	return i, err
}

const getNarInfoCount = `-- name: GetNarInfoCount :one
SELECT CAST(COUNT(*) AS BIGINT) AS count
FROM narinfos
`

// GetNarInfoCount
//
//	SELECT CAST(COUNT(*) AS BIGINT) AS count
//	FROM narinfos
func (q *Queries) GetNarInfoCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNarInfoCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNarInfoHashesByNarFileID = `-- name: GetNarInfoHashesByNarFileID :many
SELECT ni.hash
FROM narinfos ni
INNER JOIN narinfo_nar_files nnf ON ni.id = nnf.narinfo_id
WHERE nnf.nar_file_id = $1
`

// GetNarInfoHashesByNarFileID
//
//	SELECT ni.hash
//	FROM narinfos ni
//	INNER JOIN narinfo_nar_files nnf ON ni.id = nnf.narinfo_id
//	WHERE nnf.nar_file_id = $1
func (q *Queries) GetNarInfoHashesByNarFileID(ctx context.Context, narFileID int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getNarInfoHashesByNarFileID, narFileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var hash string
		if err := rows.Scan(&hash); err != nil {
			return nil, err
		}
		items = append(items, hash)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNarInfoHashesByURL = `-- name: GetNarInfoHashesByURL :many
SELECT hash
FROM narinfos
WHERE url = $1
`

// GetNarInfoHashesByURL
//
//	SELECT hash
//	FROM narinfos
//	WHERE url = $1
func (q *Queries) GetNarInfoHashesByURL(ctx context.Context, url sql.NullString) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getNarInfoHashesByURL, url)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var hash string
		if err := rows.Scan(&hash); err != nil {
			return nil, err
		}
		items = append(items, hash)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNarInfoHashesToChunk = `-- name: GetNarInfoHashesToChunk :many
SELECT ni.hash, ni.url
FROM narinfos ni
LEFT JOIN narinfo_nar_files nnf ON ni.id = nnf.narinfo_id
LEFT JOIN nar_files nf ON nnf.nar_file_id = nf.id
WHERE ni.url IS NOT NULL
  AND (nf.id IS NULL OR nf.total_chunks = 0)
ORDER BY ni.hash
`

type GetNarInfoHashesToChunkRow struct {
	Hash string
	URL  sql.NullString
}

// Get all narinfo hashes that have a URL (migrated) but whose NAR is not yet chunked.
//
//	SELECT ni.hash, ni.url
//	FROM narinfos ni
//	LEFT JOIN narinfo_nar_files nnf ON ni.id = nnf.narinfo_id
//	LEFT JOIN nar_files nf ON nnf.nar_file_id = nf.id
//	WHERE ni.url IS NOT NULL
//	  AND (nf.id IS NULL OR nf.total_chunks = 0)
//	ORDER BY ni.hash
func (q *Queries) GetNarInfoHashesToChunk(ctx context.Context) ([]GetNarInfoHashesToChunkRow, error) {
	rows, err := q.db.QueryContext(ctx, getNarInfoHashesToChunk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNarInfoHashesToChunkRow
	for rows.Next() {
		var i GetNarInfoHashesToChunkRow
		if err := rows.Scan(&i.Hash, &i.URL); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNarInfoReferences = `-- name: GetNarInfoReferences :many
SELECT reference
FROM narinfo_references
WHERE narinfo_id = $1
`

// GetNarInfoReferences
//
//	SELECT reference
//	FROM narinfo_references
//	WHERE narinfo_id = $1
func (q *Queries) GetNarInfoReferences(ctx context.Context, narinfoID int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getNarInfoReferences, narinfoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var reference string
		if err := rows.Scan(&reference); err != nil {
			return nil, err
		}
		items = append(items, reference)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNarInfoSignatures = `-- name: GetNarInfoSignatures :many
SELECT signature
FROM narinfo_signatures
WHERE narinfo_id = $1
`

// GetNarInfoSignatures
//
//	SELECT signature
//	FROM narinfo_signatures
//	WHERE narinfo_id = $1
func (q *Queries) GetNarInfoSignatures(ctx context.Context, narinfoID int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getNarInfoSignatures, narinfoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var signature string
		if err := rows.Scan(&signature); err != nil {
			return nil, err
		}
		items = append(items, signature)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNarInfoURLByNarFileHash = `-- name: GetNarInfoURLByNarFileHash :one
SELECT ni.url
FROM narinfos ni
INNER JOIN narinfo_nar_files nnf ON ni.id = nnf.narinfo_id
INNER JOIN nar_files nf ON nf.id = nnf.nar_file_id
WHERE nf.hash = $1 AND nf.compression = $2 AND nf.query = $3
LIMIT 1
`

type GetNarInfoURLByNarFileHashParams struct {
	Hash        string
	Compression string
	Query       string
}

// GetNarInfoURLByNarFileHash
//
//	SELECT ni.url
//	FROM narinfos ni
//	INNER JOIN narinfo_nar_files nnf ON ni.id = nnf.narinfo_id
//	INNER JOIN nar_files nf ON nf.id = nnf.nar_file_id
//	WHERE nf.hash = $1 AND nf.compression = $2 AND nf.query = $3
//	LIMIT 1
func (q *Queries) GetNarInfoURLByNarFileHash(ctx context.Context, arg GetNarInfoURLByNarFileHashParams) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getNarInfoURLByNarFileHash, arg.Hash, arg.Compression, arg.Query)
	var url sql.NullString
	err := row.Scan(&url)
	return url, err
}

const getNarTotalSize = `-- name: GetNarTotalSize :one
SELECT CAST(COALESCE(SUM(file_size), 0) AS BIGINT) AS total_size
FROM nar_files
`

// GetNarTotalSize
//
//	SELECT CAST(COALESCE(SUM(file_size), 0) AS BIGINT) AS total_size
//	FROM nar_files
func (q *Queries) GetNarTotalSize(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNarTotalSize)
	var total_size int64
	err := row.Scan(&total_size)
	return total_size, err
}

const getOldCompressedNarFiles = `-- name: GetOldCompressedNarFiles :many
SELECT id, hash, compression, file_size, query, created_at, updated_at, last_accessed_at, total_chunks, chunking_started_at
FROM nar_files
WHERE compression NOT IN ('', 'none')
  AND created_at < $1
ORDER BY id
LIMIT $2 OFFSET $3
`

type GetOldCompressedNarFilesParams struct {
	CreatedAt time.Time
	Limit     int32
	Offset    int32
}

// GetOldCompressedNarFiles
//
//	SELECT id, hash, compression, file_size, query, created_at, updated_at, last_accessed_at, total_chunks, chunking_started_at
//	FROM nar_files
//	WHERE compression NOT IN ('', 'none')
//	  AND created_at < $1
//	ORDER BY id
//	LIMIT $2 OFFSET $3
func (q *Queries) GetOldCompressedNarFiles(ctx context.Context, arg GetOldCompressedNarFilesParams) ([]NarFile, error) {
	rows, err := q.db.QueryContext(ctx, getOldCompressedNarFiles, arg.CreatedAt, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NarFile
	for rows.Next() {
		var i NarFile
		if err := rows.Scan(
			&i.ID,
			&i.Hash,
			&i.Compression,
			&i.FileSize,
			&i.Query,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastAccessedAt,
			&i.TotalChunks,
			&i.ChunkingStartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrphanedChunks = `-- name: GetOrphanedChunks :many
SELECT c.id, c.hash, c.size, c.created_at, c.updated_at
FROM chunks c
LEFT JOIN nar_file_chunks nfc ON c.id = nfc.chunk_id
WHERE nfc.chunk_id IS NULL
`

type GetOrphanedChunksRow struct {
	ID        int64
	Hash      string
	Size      uint32
	CreatedAt time.Time
	UpdatedAt sql.NullTime
}

// GetOrphanedChunks
//
//	SELECT c.id, c.hash, c.size, c.created_at, c.updated_at
//	FROM chunks c
//	LEFT JOIN nar_file_chunks nfc ON c.id = nfc.chunk_id
//	WHERE nfc.chunk_id IS NULL
func (q *Queries) GetOrphanedChunks(ctx context.Context) ([]GetOrphanedChunksRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrphanedChunks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrphanedChunksRow
	for rows.Next() {
		var i GetOrphanedChunksRow
		if err := rows.Scan(
			&i.ID,
			&i.Hash,
			&i.Size,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrphanedNarFiles = `-- name: GetOrphanedNarFiles :many
SELECT nf.id, nf.hash, nf.compression, nf.file_size, nf.query, nf.created_at, nf.updated_at, nf.last_accessed_at
FROM nar_files nf
LEFT JOIN narinfo_nar_files ninf ON nf.id = ninf.nar_file_id
WHERE ninf.narinfo_id IS NULL
`

type GetOrphanedNarFilesRow struct {
	ID             int64
	Hash           string
	Compression    string
	FileSize       uint64
	Query          string
	CreatedAt      time.Time
	UpdatedAt      sql.NullTime
	LastAccessedAt sql.NullTime
}

// Find files that have no relationship to any narinfo
//
//	SELECT nf.id, nf.hash, nf.compression, nf.file_size, nf.query, nf.created_at, nf.updated_at, nf.last_accessed_at
//	FROM nar_files nf
//	LEFT JOIN narinfo_nar_files ninf ON nf.id = ninf.nar_file_id
//	WHERE ninf.narinfo_id IS NULL
func (q *Queries) GetOrphanedNarFiles(ctx context.Context) ([]GetOrphanedNarFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrphanedNarFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrphanedNarFilesRow
	for rows.Next() {
		var i GetOrphanedNarFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.Hash,
			&i.Compression,
			&i.FileSize,
			&i.Query,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastAccessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalChunkSize = `-- name: GetTotalChunkSize :one
SELECT CAST(COALESCE(SUM(size), 0) AS BIGINT) AS total_size
FROM chunks
`

// GetTotalChunkSize
//
//	SELECT CAST(COALESCE(SUM(size), 0) AS BIGINT) AS total_size
//	FROM chunks
func (q *Queries) GetTotalChunkSize(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalChunkSize)
	var total_size int64
	err := row.Scan(&total_size)
	return total_size, err
}

const getUnmigratedNarInfoHashes = `-- name: GetUnmigratedNarInfoHashes :many
SELECT hash
FROM narinfos
WHERE url IS NULL
`

// Get all narinfo hashes that have no URL (unmigrated).
//
//	SELECT hash
//	FROM narinfos
//	WHERE url IS NULL
func (q *Queries) GetUnmigratedNarInfoHashes(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUnmigratedNarInfoHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var hash string
		if err := rows.Scan(&hash); err != nil {
			return nil, err
		}
		items = append(items, hash)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isNarInfoMigrated = `-- name: IsNarInfoMigrated :one
SELECT EXISTS(
    SELECT 1
    FROM narinfos
    WHERE hash = $1 AND url IS NOT NULL
) AS is_migrated
`

// Check if a narinfo hash has been migrated (has a URL).
//
//	SELECT EXISTS(
//	    SELECT 1
//	    FROM narinfos
//	    WHERE hash = $1 AND url IS NOT NULL
//	) AS is_migrated
func (q *Queries) IsNarInfoMigrated(ctx context.Context, hash string) (bool, error) {
	row := q.db.QueryRowContext(ctx, isNarInfoMigrated, hash)
	var is_migrated bool
	err := row.Scan(&is_migrated)
	return is_migrated, err
}

const linkNarFileToChunk = `-- name: LinkNarFileToChunk :exec
INSERT INTO nar_file_chunks (
    nar_file_id, chunk_id, chunk_index
) VALUES (
    $1, $2, $3
)
ON CONFLICT (nar_file_id, chunk_index) DO NOTHING
`

type LinkNarFileToChunkParams struct {
	NarFileID  int64
	ChunkID    int64
	ChunkIndex int64
}

// LinkNarFileToChunk
//
//	INSERT INTO nar_file_chunks (
//	    nar_file_id, chunk_id, chunk_index
//	) VALUES (
//	    $1, $2, $3
//	)
//	ON CONFLICT (nar_file_id, chunk_index) DO NOTHING
func (q *Queries) LinkNarFileToChunk(ctx context.Context, arg LinkNarFileToChunkParams) error {
	_, err := q.db.ExecContext(ctx, linkNarFileToChunk, arg.NarFileID, arg.ChunkID, arg.ChunkIndex)
	return err
}

const linkNarFileToChunks = `-- name: LinkNarFileToChunks :exec
INSERT INTO nar_file_chunks (
    nar_file_id, chunk_id, chunk_index
)
SELECT $1, unnest($2::bigint[]), unnest($3::bigint[])
ON CONFLICT (nar_file_id, chunk_index) DO NOTHING
`

type LinkNarFileToChunksParams struct {
	NarFileID  int64
	ChunkID    []int64
	ChunkIndex []int64
}

// @bulk-for LinkNarFileToChunk
//
//	INSERT INTO nar_file_chunks (
//	    nar_file_id, chunk_id, chunk_index
//	)
//	SELECT $1, unnest($2::bigint[]), unnest($3::bigint[])
//	ON CONFLICT (nar_file_id, chunk_index) DO NOTHING
func (q *Queries) LinkNarFileToChunks(ctx context.Context, arg LinkNarFileToChunksParams) error {
	_, err := q.db.ExecContext(ctx, linkNarFileToChunks, arg.NarFileID, pq.Array(arg.ChunkID), pq.Array(arg.ChunkIndex))
	return err
}

const linkNarInfoToNarFile = `-- name: LinkNarInfoToNarFile :exec
INSERT INTO narinfo_nar_files (
    narinfo_id, nar_file_id
) VALUES (
    $1, $2
)
ON CONFLICT (narinfo_id, nar_file_id) DO NOTHING
`

type LinkNarInfoToNarFileParams struct {
	NarInfoID int64
	NarFileID int64
}

// LinkNarInfoToNarFile
//
//	INSERT INTO narinfo_nar_files (
//	    narinfo_id, nar_file_id
//	) VALUES (
//	    $1, $2
//	)
//	ON CONFLICT (narinfo_id, nar_file_id) DO NOTHING
func (q *Queries) LinkNarInfoToNarFile(ctx context.Context, arg LinkNarInfoToNarFileParams) error {
	_, err := q.db.ExecContext(ctx, linkNarInfoToNarFile, arg.NarInfoID, arg.NarFileID)
	return err
}

const linkNarInfosByURLToNarFile = `-- name: LinkNarInfosByURLToNarFile :exec
INSERT INTO narinfo_nar_files (narinfo_id, nar_file_id)
SELECT id, $1
FROM narinfos
WHERE url = $2
ON CONFLICT (narinfo_id, nar_file_id) DO NOTHING
`

type LinkNarInfosByURLToNarFileParams struct {
	NarFileID int64
	URL       sql.NullString
}

// LinkNarInfosByURLToNarFile
//
//	INSERT INTO narinfo_nar_files (narinfo_id, nar_file_id)
//	SELECT id, $1
//	FROM narinfos
//	WHERE url = $2
//	ON CONFLICT (narinfo_id, nar_file_id) DO NOTHING
func (q *Queries) LinkNarInfosByURLToNarFile(ctx context.Context, arg LinkNarInfosByURLToNarFileParams) error {
	_, err := q.db.ExecContext(ctx, linkNarInfosByURLToNarFile, arg.NarFileID, arg.URL)
	return err
}

const setConfig = `-- name: SetConfig :exec
INSERT INTO config (
    key, value
) VALUES (
    $1, $2
)
ON CONFLICT(key)
DO UPDATE SET
  value = EXCLUDED.value,
  updated_at = CURRENT_TIMESTAMP
`

type SetConfigParams struct {
	Key   string
	Value string
}

// SetConfig
//
//	INSERT INTO config (
//	    key, value
//	) VALUES (
//	    $1, $2
//	)
//	ON CONFLICT(key)
//	DO UPDATE SET
//	  value = EXCLUDED.value,
//	  updated_at = CURRENT_TIMESTAMP
func (q *Queries) SetConfig(ctx context.Context, arg SetConfigParams) error {
	_, err := q.db.ExecContext(ctx, setConfig, arg.Key, arg.Value)
	return err
}

const setNarFileChunkingStarted = `-- name: SetNarFileChunkingStarted :exec
UPDATE nar_files
SET chunking_started_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

// SetNarFileChunkingStarted
//
//	UPDATE nar_files
//	SET chunking_started_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
//	WHERE id = $1
func (q *Queries) SetNarFileChunkingStarted(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, setNarFileChunkingStarted, id)
	return err
}

const touchNarFile = `-- name: TouchNarFile :execrows
UPDATE nar_files
SET
    last_accessed_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE hash = $1 AND compression = $2 AND query = $3
`

type TouchNarFileParams struct {
	Hash        string
	Compression string
	Query       string
}

// TouchNarFile
//
//	UPDATE nar_files
//	SET
//	    last_accessed_at = CURRENT_TIMESTAMP,
//	    updated_at = CURRENT_TIMESTAMP
//	WHERE hash = $1 AND compression = $2 AND query = $3
func (q *Queries) TouchNarFile(ctx context.Context, arg TouchNarFileParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, touchNarFile, arg.Hash, arg.Compression, arg.Query)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const touchNarInfo = `-- name: TouchNarInfo :execrows
UPDATE narinfos
SET
    last_accessed_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE hash = $1
`

// TouchNarInfo
//
//	UPDATE narinfos
//	SET
//	    last_accessed_at = CURRENT_TIMESTAMP,
//	    updated_at = CURRENT_TIMESTAMP
//	WHERE hash = $1
func (q *Queries) TouchNarInfo(ctx context.Context, hash string) (int64, error) {
	result, err := q.db.ExecContext(ctx, touchNarInfo, hash)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateNarFileFileSize = `-- name: UpdateNarFileFileSize :exec
UPDATE nar_files
SET file_size = $1, updated_at = CURRENT_TIMESTAMP
WHERE id = $2
`

type UpdateNarFileFileSizeParams struct {
	FileSize uint64
	ID       int64
}

// UpdateNarFileFileSize
//
//	UPDATE nar_files
//	SET file_size = $1, updated_at = CURRENT_TIMESTAMP
//	WHERE id = $2
func (q *Queries) UpdateNarFileFileSize(ctx context.Context, arg UpdateNarFileFileSizeParams) error {
	_, err := q.db.ExecContext(ctx, updateNarFileFileSize, arg.FileSize, arg.ID)
	return err
}

const updateNarFileTotalChunks = `-- name: UpdateNarFileTotalChunks :exec
UPDATE nar_files
SET total_chunks = $1, file_size = $2, updated_at = CURRENT_TIMESTAMP, chunking_started_at = NULL
WHERE id = $3
`

type UpdateNarFileTotalChunksParams struct {
	TotalChunks int64
	FileSize    uint64
	ID          int64
}

// UpdateNarFileTotalChunks
//
//	UPDATE nar_files
//	SET total_chunks = $1, file_size = $2, updated_at = CURRENT_TIMESTAMP, chunking_started_at = NULL
//	WHERE id = $3
func (q *Queries) UpdateNarFileTotalChunks(ctx context.Context, arg UpdateNarFileTotalChunksParams) error {
	_, err := q.db.ExecContext(ctx, updateNarFileTotalChunks, arg.TotalChunks, arg.FileSize, arg.ID)
	return err
}

const updateNarInfo = `-- name: UpdateNarInfo :one
UPDATE narinfos
SET
    store_path = $2,
    url = $3,
    compression = $4,
    file_hash = $5,
    file_size = $6,
    nar_hash = $7,
    nar_size = $8,
    deriver = $9,
    system = $10,
    ca = $11,
    updated_at = CURRENT_TIMESTAMP
WHERE hash = $1
RETURNING id, hash, created_at, updated_at, last_accessed_at, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, system, ca
`

type UpdateNarInfoParams struct {
	Hash        string
	StorePath   sql.NullString
	URL         sql.NullString
	Compression sql.NullString
	FileHash    sql.NullString
	FileSize    sql.NullInt64
	NarHash     sql.NullString
	NarSize     sql.NullInt64
	Deriver     sql.NullString
	System      sql.NullString
	Ca          sql.NullString
}

// UpdateNarInfo
//
//	UPDATE narinfos
//	SET
//	    store_path = $2,
//	    url = $3,
//	    compression = $4,
//	    file_hash = $5,
//	    file_size = $6,
//	    nar_hash = $7,
//	    nar_size = $8,
//	    deriver = $9,
//	    system = $10,
//	    ca = $11,
//	    updated_at = CURRENT_TIMESTAMP
//	WHERE hash = $1
//	RETURNING id, hash, created_at, updated_at, last_accessed_at, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, system, ca
func (q *Queries) UpdateNarInfo(ctx context.Context, arg UpdateNarInfoParams) (NarInfo, error) {
	row := q.db.QueryRowContext(ctx, updateNarInfo,
		arg.Hash,
		arg.StorePath,
		arg.URL,
		arg.Compression,
		arg.FileHash,
		arg.FileSize,
		arg.NarHash,
		arg.NarSize,
		arg.Deriver,
		arg.System,
		arg.Ca,
	)
	var i NarInfo
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAccessedAt,
		&i.StorePath,
		&i.URL,
		&i.Compression,
		&i.FileHash,
		&i.FileSize,
		&i.NarHash,
		&i.NarSize,
		&i.Deriver,
		&i.System,
		&i.Ca,
	)
	return i, err
}

const updateNarInfoCompressionAndURL = `-- name: UpdateNarInfoCompressionAndURL :execrows
UPDATE narinfos
SET compression = $1, url = $2, updated_at = CURRENT_TIMESTAMP
WHERE url = $3
`

type UpdateNarInfoCompressionAndURLParams struct {
	Compression sql.NullString
	NewUrl      sql.NullString
	OldUrl      sql.NullString
}

// Update narinfo compression and URL after CDC migration.
//
//	UPDATE narinfos
//	SET compression = $1, url = $2, updated_at = CURRENT_TIMESTAMP
//	WHERE url = $3
func (q *Queries) UpdateNarInfoCompressionAndURL(ctx context.Context, arg UpdateNarInfoCompressionAndURLParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateNarInfoCompressionAndURL, arg.Compression, arg.NewUrl, arg.OldUrl)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateNarInfoFileHash = `-- name: UpdateNarInfoFileHash :exec
UPDATE narinfos
SET file_hash = $2, updated_at = CURRENT_TIMESTAMP
WHERE hash = $1
`

type UpdateNarInfoFileHashParams struct {
	Hash     string
	FileHash sql.NullString
}

// UpdateNarInfoFileHash
//
//	UPDATE narinfos
//	SET file_hash = $2, updated_at = CURRENT_TIMESTAMP
//	WHERE hash = $1
func (q *Queries) UpdateNarInfoFileHash(ctx context.Context, arg UpdateNarInfoFileHashParams) error {
	_, err := q.db.ExecContext(ctx, updateNarInfoFileHash, arg.Hash, arg.FileHash)
	return err
}

const updateNarInfoFileSize = `-- name: UpdateNarInfoFileSize :exec
UPDATE narinfos
SET file_size = $2, updated_at = CURRENT_TIMESTAMP
WHERE hash = $1
`

type UpdateNarInfoFileSizeParams struct {
	Hash     string
	FileSize sql.NullInt64
}

// UpdateNarInfoFileSize
//
//	UPDATE narinfos
//	SET file_size = $2, updated_at = CURRENT_TIMESTAMP
//	WHERE hash = $1
func (q *Queries) UpdateNarInfoFileSize(ctx context.Context, arg UpdateNarInfoFileSizeParams) error {
	_, err := q.db.ExecContext(ctx, updateNarInfoFileSize, arg.Hash, arg.FileSize)
	return err
}
