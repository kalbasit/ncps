// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.postgres.sql

package postgresdb

import (
	"context"
)

const createNarFile = `-- name: CreateNarFile :one
INSERT INTO nar_files (
    hash, compression, query, file_size
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, hash, compression, file_size, query, created_at, updated_at, last_accessed_at
`

type CreateNarFileParams struct {
	Hash        string
	Compression string
	Query       string
	FileSize    int64
}

// CreateNarFile
//
//	INSERT INTO nar_files (
//	    hash, compression, query, file_size
//	) VALUES (
//	    $1, $2, $3, $4
//	)
//	RETURNING id, hash, compression, file_size, query, created_at, updated_at, last_accessed_at
func (q *Queries) CreateNarFile(ctx context.Context, arg CreateNarFileParams) (NarFile, error) {
	row := q.db.QueryRowContext(ctx, createNarFile,
		arg.Hash,
		arg.Compression,
		arg.Query,
		arg.FileSize,
	)
	var i NarFile
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Compression,
		&i.FileSize,
		&i.Query,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAccessedAt,
	)
	return i, err
}

const createNarInfo = `-- name: CreateNarInfo :one
INSERT INTO narinfos (
    hash
) VALUES (
    $1
)
RETURNING id, hash, created_at, updated_at, last_accessed_at
`

// CreateNarInfo
//
//	INSERT INTO narinfos (
//	    hash
//	) VALUES (
//	    $1
//	)
//	RETURNING id, hash, created_at, updated_at, last_accessed_at
func (q *Queries) CreateNarInfo(ctx context.Context, hash string) (NarInfo, error) {
	row := q.db.QueryRowContext(ctx, createNarInfo, hash)
	var i NarInfo
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAccessedAt,
	)
	return i, err
}

const deleteNarFileByHash = `-- name: DeleteNarFileByHash :execrows
DELETE FROM nar_files
WHERE hash = $1
`

// DeleteNarFileByHash
//
//	DELETE FROM nar_files
//	WHERE hash = $1
func (q *Queries) DeleteNarFileByHash(ctx context.Context, hash string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteNarFileByHash, hash)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteNarFileByID = `-- name: DeleteNarFileByID :execrows
DELETE FROM nar_files
WHERE id = $1
`

// DeleteNarFileByID
//
//	DELETE FROM nar_files
//	WHERE id = $1
func (q *Queries) DeleteNarFileByID(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteNarFileByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteNarInfoByHash = `-- name: DeleteNarInfoByHash :execrows
DELETE FROM narinfos
WHERE hash = $1
`

// DeleteNarInfoByHash
//
//	DELETE FROM narinfos
//	WHERE hash = $1
func (q *Queries) DeleteNarInfoByHash(ctx context.Context, hash string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteNarInfoByHash, hash)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteNarInfoByID = `-- name: DeleteNarInfoByID :execrows
DELETE FROM narinfos
WHERE id = $1
`

// DeleteNarInfoByID
//
//	DELETE FROM narinfos
//	WHERE id = $1
func (q *Queries) DeleteNarInfoByID(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteNarInfoByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteOrphanedNarFiles = `-- name: DeleteOrphanedNarFiles :execrows
DELETE FROM nar_files
WHERE id NOT IN (
    SELECT DISTINCT nar_file_id
    FROM narinfo_nar_files
)
`

// DeleteOrphanedNarFiles
//
//	DELETE FROM nar_files
//	WHERE id NOT IN (
//	    SELECT DISTINCT nar_file_id
//	    FROM narinfo_nar_files
//	)
func (q *Queries) DeleteOrphanedNarFiles(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteOrphanedNarFiles)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteOrphanedNarInfos = `-- name: DeleteOrphanedNarInfos :execrows
DELETE FROM narinfos
WHERE id NOT IN (
    SELECT DISTINCT narinfo_id
    FROM narinfo_nar_files
)
`

// DeleteOrphanedNarInfos
//
//	DELETE FROM narinfos
//	WHERE id NOT IN (
//	    SELECT DISTINCT narinfo_id
//	    FROM narinfo_nar_files
//	)
func (q *Queries) DeleteOrphanedNarInfos(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteOrphanedNarInfos)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getLeastUsedNarFiles = `-- name: GetLeastUsedNarFiles :many
SELECT n1.id, n1.hash, n1.compression, n1.file_size, n1.query, n1.created_at, n1.updated_at, n1.last_accessed_at
FROM nar_files n1
WHERE (
    SELECT SUM(n2.file_size)
    FROM nar_files n2
    WHERE n2.last_accessed_at < n1.last_accessed_at
       OR (n2.last_accessed_at = n1.last_accessed_at AND n2.id <= n1.id)
) <= $1
`

// NOTE: This query uses a correlated subquery which is not optimal for performance.
// The ideal implementation would use a window function (SUM OVER), but sqlc v1.30.0
// does not properly support filtering on window function results in subqueries.
//
//	SELECT n1.id, n1.hash, n1.compression, n1.file_size, n1.query, n1.created_at, n1.updated_at, n1.last_accessed_at
//	FROM nar_files n1
//	WHERE (
//	    SELECT SUM(n2.file_size)
//	    FROM nar_files n2
//	    WHERE n2.last_accessed_at < n1.last_accessed_at
//	       OR (n2.last_accessed_at = n1.last_accessed_at AND n2.id <= n1.id)
//	) <= $1
func (q *Queries) GetLeastUsedNarFiles(ctx context.Context, fileSize int64) ([]NarFile, error) {
	rows, err := q.db.QueryContext(ctx, getLeastUsedNarFiles, fileSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NarFile
	for rows.Next() {
		var i NarFile
		if err := rows.Scan(
			&i.ID,
			&i.Hash,
			&i.Compression,
			&i.FileSize,
			&i.Query,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastAccessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeastUsedNarInfos = `-- name: GetLeastUsedNarInfos :many
SELECT ni1.id, ni1.hash, ni1.created_at, ni1.updated_at, ni1.last_accessed_at
FROM narinfos ni1
WHERE (
    SELECT COALESCE(SUM(nf2.file_size), 0)
    FROM narinfos ni2
    LEFT JOIN narinfo_nar_files ninf2 ON ni2.id = ninf2.narinfo_id
    LEFT JOIN nar_files nf2 ON ninf2.nar_file_id = nf2.id
    WHERE ni2.last_accessed_at < ni1.last_accessed_at
        OR (ni2.last_accessed_at = ni1.last_accessed_at AND ni2.id <= ni1.id)
) <= $1
`

// NOTE: This query uses a correlated subquery which is not optimal for performance.
// The ideal implementation would use a window function (SUM OVER), but sqlc v1.30.0
// does not properly support filtering on window function results in subqueries.
// Gets the least-used narinfos up to a certain total file size (accounting for their nar_files).
//
//	SELECT ni1.id, ni1.hash, ni1.created_at, ni1.updated_at, ni1.last_accessed_at
//	FROM narinfos ni1
//	WHERE (
//	    SELECT COALESCE(SUM(nf2.file_size), 0)
//	    FROM narinfos ni2
//	    LEFT JOIN narinfo_nar_files ninf2 ON ni2.id = ninf2.narinfo_id
//	    LEFT JOIN nar_files nf2 ON ninf2.nar_file_id = nf2.id
//	    WHERE ni2.last_accessed_at < ni1.last_accessed_at
//	        OR (ni2.last_accessed_at = ni1.last_accessed_at AND ni2.id <= ni1.id)
//	) <= $1
func (q *Queries) GetLeastUsedNarInfos(ctx context.Context, fileSize int64) ([]NarInfo, error) {
	rows, err := q.db.QueryContext(ctx, getLeastUsedNarInfos, fileSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NarInfo
	for rows.Next() {
		var i NarInfo
		if err := rows.Scan(
			&i.ID,
			&i.Hash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastAccessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNarFileByHash = `-- name: GetNarFileByHash :one
SELECT id, hash, compression, file_size, query, created_at, updated_at, last_accessed_at
FROM nar_files
WHERE hash = $1
`

// GetNarFileByHash
//
//	SELECT id, hash, compression, file_size, query, created_at, updated_at, last_accessed_at
//	FROM nar_files
//	WHERE hash = $1
func (q *Queries) GetNarFileByHash(ctx context.Context, hash string) (NarFile, error) {
	row := q.db.QueryRowContext(ctx, getNarFileByHash, hash)
	var i NarFile
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Compression,
		&i.FileSize,
		&i.Query,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAccessedAt,
	)
	return i, err
}

const getNarFileByID = `-- name: GetNarFileByID :one
SELECT id, hash, compression, file_size, query, created_at, updated_at, last_accessed_at
FROM nar_files
WHERE id = $1
`

// GetNarFileByID
//
//	SELECT id, hash, compression, file_size, query, created_at, updated_at, last_accessed_at
//	FROM nar_files
//	WHERE id = $1
func (q *Queries) GetNarFileByID(ctx context.Context, id int32) (NarFile, error) {
	row := q.db.QueryRowContext(ctx, getNarFileByID, id)
	var i NarFile
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Compression,
		&i.FileSize,
		&i.Query,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAccessedAt,
	)
	return i, err
}

const getNarFileByNarInfoID = `-- name: GetNarFileByNarInfoID :one
SELECT nf.id, nf.hash, nf.compression, nf.file_size, nf.query, nf.created_at, nf.updated_at, nf.last_accessed_at
FROM nar_files nf
INNER JOIN narinfo_nar_files nnf ON nf.id = nnf.nar_file_id
WHERE nnf.narinfo_id = $1
`

// GetNarFileByNarInfoID
//
//	SELECT nf.id, nf.hash, nf.compression, nf.file_size, nf.query, nf.created_at, nf.updated_at, nf.last_accessed_at
//	FROM nar_files nf
//	INNER JOIN narinfo_nar_files nnf ON nf.id = nnf.nar_file_id
//	WHERE nnf.narinfo_id = $1
func (q *Queries) GetNarFileByNarInfoID(ctx context.Context, narinfoID int32) (NarFile, error) {
	row := q.db.QueryRowContext(ctx, getNarFileByNarInfoID, narinfoID)
	var i NarFile
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Compression,
		&i.FileSize,
		&i.Query,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAccessedAt,
	)
	return i, err
}

const getNarInfoByHash = `-- name: GetNarInfoByHash :one
SELECT id, hash, created_at, updated_at, last_accessed_at
FROM narinfos
WHERE hash = $1
`

// GetNarInfoByHash
//
//	SELECT id, hash, created_at, updated_at, last_accessed_at
//	FROM narinfos
//	WHERE hash = $1
func (q *Queries) GetNarInfoByHash(ctx context.Context, hash string) (NarInfo, error) {
	row := q.db.QueryRowContext(ctx, getNarInfoByHash, hash)
	var i NarInfo
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAccessedAt,
	)
	return i, err
}

const getNarInfoByID = `-- name: GetNarInfoByID :one
SELECT id, hash, created_at, updated_at, last_accessed_at
FROM narinfos
WHERE id = $1
`

// GetNarInfoByID
//
//	SELECT id, hash, created_at, updated_at, last_accessed_at
//	FROM narinfos
//	WHERE id = $1
func (q *Queries) GetNarInfoByID(ctx context.Context, id int64) (NarInfo, error) {
	row := q.db.QueryRowContext(ctx, getNarInfoByID, id)
	var i NarInfo
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastAccessedAt,
	)
	return i, err
}

const getNarInfoHashesByNarFileID = `-- name: GetNarInfoHashesByNarFileID :many
SELECT ni.hash
FROM narinfos ni
INNER JOIN narinfo_nar_files nnf ON ni.id = nnf.narinfo_id
WHERE nnf.nar_file_id = $1
`

// GetNarInfoHashesByNarFileID
//
//	SELECT ni.hash
//	FROM narinfos ni
//	INNER JOIN narinfo_nar_files nnf ON ni.id = nnf.narinfo_id
//	WHERE nnf.nar_file_id = $1
func (q *Queries) GetNarInfoHashesByNarFileID(ctx context.Context, narFileID int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getNarInfoHashesByNarFileID, narFileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var hash string
		if err := rows.Scan(&hash); err != nil {
			return nil, err
		}
		items = append(items, hash)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNarTotalSize = `-- name: GetNarTotalSize :one
SELECT CAST(COALESCE(SUM(file_size), 0) AS BIGINT) AS total_size
FROM nar_files
`

// GetNarTotalSize
//
//	SELECT CAST(COALESCE(SUM(file_size), 0) AS BIGINT) AS total_size
//	FROM nar_files
func (q *Queries) GetNarTotalSize(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNarTotalSize)
	var total_size int64
	err := row.Scan(&total_size)
	return total_size, err
}

const getOrphanedNarInfoHashes = `-- name: GetOrphanedNarInfoHashes :many
SELECT hash FROM narinfos
WHERE id NOT IN (
  SELECT DISTINCT narinfo_id
  FROM narinfo_nar_files
)
`

// GetOrphanedNarInfoHashes
//
//	SELECT hash FROM narinfos
//	WHERE id NOT IN (
//	  SELECT DISTINCT narinfo_id
//	  FROM narinfo_nar_files
//	)
func (q *Queries) GetOrphanedNarInfoHashes(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getOrphanedNarInfoHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var hash string
		if err := rows.Scan(&hash); err != nil {
			return nil, err
		}
		items = append(items, hash)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkNarInfoToNarFile = `-- name: LinkNarInfoToNarFile :exec
INSERT INTO narinfo_nar_files (
    narinfo_id, nar_file_id
) VALUES (
    $1, $2
)
`

type LinkNarInfoToNarFileParams struct {
	NarInfoID int32
	NarFileID int32
}

// LinkNarInfoToNarFile
//
//	INSERT INTO narinfo_nar_files (
//	    narinfo_id, nar_file_id
//	) VALUES (
//	    $1, $2
//	)
func (q *Queries) LinkNarInfoToNarFile(ctx context.Context, arg LinkNarInfoToNarFileParams) error {
	_, err := q.db.ExecContext(ctx, linkNarInfoToNarFile, arg.NarInfoID, arg.NarFileID)
	return err
}

const touchNarFile = `-- name: TouchNarFile :execrows
UPDATE nar_files
SET
    last_accessed_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE hash = $1
`

// TouchNarFile
//
//	UPDATE nar_files
//	SET
//	    last_accessed_at = CURRENT_TIMESTAMP,
//	    updated_at = CURRENT_TIMESTAMP
//	WHERE hash = $1
func (q *Queries) TouchNarFile(ctx context.Context, hash string) (int64, error) {
	result, err := q.db.ExecContext(ctx, touchNarFile, hash)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const touchNarInfo = `-- name: TouchNarInfo :execrows
UPDATE narinfos
SET
    last_accessed_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE hash = $1
`

// TouchNarInfo
//
//	UPDATE narinfos
//	SET
//	    last_accessed_at = CURRENT_TIMESTAMP,
//	    updated_at = CURRENT_TIMESTAMP
//	WHERE hash = $1
func (q *Queries) TouchNarInfo(ctx context.Context, hash string) (int64, error) {
	result, err := q.db.ExecContext(ctx, touchNarInfo, hash)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
