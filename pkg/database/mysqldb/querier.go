// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package mysqldb

import (
	"context"
	"database/sql"
)

type Querier interface {
	//AddNarInfoReference
	//
	//  INSERT IGNORE INTO narinfo_references (
	//      narinfo_id, reference
	//  ) VALUES (
	//      ?, ?
	//  )
	AddNarInfoReference(ctx context.Context, arg AddNarInfoReferenceParams) error
	//AddNarInfoSignature
	//
	//  INSERT IGNORE INTO narinfo_signatures (
	//      narinfo_id, signature
	//  ) VALUES (
	//      ?, ?
	//  )
	AddNarInfoSignature(ctx context.Context, arg AddNarInfoSignatureParams) error
	//CreateChunk
	//
	//  INSERT INTO chunks (
	//      hash, size, compressed_size
	//  ) VALUES (
	//      ?, ?, ?
	//  )
	//  ON DUPLICATE KEY UPDATE
	//      id = LAST_INSERT_ID(id),
	//      updated_at = CURRENT_TIMESTAMP
	CreateChunk(ctx context.Context, arg CreateChunkParams) (sql.Result, error)
	//CreateConfig
	//
	//  INSERT INTO config (
	//      `key`, value
	//  ) VALUES (
	//      ?, ?
	//  )
	CreateConfig(ctx context.Context, arg CreateConfigParams) (sql.Result, error)
	//CreateNarFile
	//
	//  INSERT INTO nar_files (
	//      hash, compression, `query`, file_size, total_chunks
	//  ) VALUES (
	//      ?, ?, ?, ?, ?
	//  )
	//  ON DUPLICATE KEY UPDATE
	//      id = LAST_INSERT_ID(id),
	//      updated_at = CURRENT_TIMESTAMP
	CreateNarFile(ctx context.Context, arg CreateNarFileParams) (sql.Result, error)
	//CreateNarInfo
	//
	//  INSERT INTO narinfos (
	//      hash, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, system, ca
	//  ) VALUES (
	//      ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
	//  )
	//  ON DUPLICATE KEY UPDATE
	//      id = LAST_INSERT_ID(id),
	//      store_path = IF(url IS NULL, VALUES(store_path), store_path),
	//      compression = IF(url IS NULL, VALUES(compression), compression),
	//      file_hash = IF(url IS NULL, VALUES(file_hash), file_hash),
	//      file_size = IF(url IS NULL, VALUES(file_size), file_size),
	//      nar_hash = IF(url IS NULL, VALUES(nar_hash), nar_hash),
	//      nar_size = IF(url IS NULL, VALUES(nar_size), nar_size),
	//      deriver = IF(url IS NULL, VALUES(deriver), deriver),
	//      system = IF(url IS NULL, VALUES(system), system),
	//      ca = IF(url IS NULL, VALUES(ca), ca),
	//      url = IF(url IS NULL, VALUES(url), url),
	//      updated_at = IF(url IS NULL, CURRENT_TIMESTAMP, updated_at)
	CreateNarInfo(ctx context.Context, arg CreateNarInfoParams) (sql.Result, error)
	//DeleteChunkByID
	//
	//  DELETE FROM chunks
	//  WHERE id = ?
	DeleteChunkByID(ctx context.Context, id int64) error
	//DeleteNarFileByHash
	//
	//  DELETE FROM nar_files
	//  WHERE hash = ? AND compression = ? AND `query` = ?
	DeleteNarFileByHash(ctx context.Context, arg DeleteNarFileByHashParams) (int64, error)
	//DeleteNarFileByID
	//
	//  DELETE FROM nar_files
	//  WHERE id = ?
	DeleteNarFileByID(ctx context.Context, id int64) (int64, error)
	//DeleteNarInfoByHash
	//
	//  DELETE FROM narinfos
	//  WHERE hash = ?
	DeleteNarInfoByHash(ctx context.Context, hash string) (int64, error)
	//DeleteNarInfoByID
	//
	//  DELETE FROM narinfos
	//  WHERE id = ?
	DeleteNarInfoByID(ctx context.Context, id int64) (int64, error)
	//DeleteOrphanedNarFiles
	//
	//  DELETE FROM nar_files
	//  WHERE id NOT IN (
	//      SELECT DISTINCT nar_file_id
	//      FROM narinfo_nar_files
	//  )
	DeleteOrphanedNarFiles(ctx context.Context) (int64, error)
	//DeleteOrphanedNarInfos
	//
	//  DELETE FROM narinfos
	//  WHERE id NOT IN (
	//      SELECT DISTINCT narinfo_id
	//      FROM narinfo_nar_files
	//  )
	DeleteOrphanedNarInfos(ctx context.Context) (int64, error)
	//GetChunkByHash
	//
	//  SELECT id, hash, size, compressed_size, created_at, updated_at
	//  FROM chunks
	//  WHERE hash = ?
	GetChunkByHash(ctx context.Context, hash string) (Chunk, error)
	//GetChunkByID
	//
	//  SELECT id, hash, size, compressed_size, created_at, updated_at
	//  FROM chunks
	//  WHERE id = ?
	GetChunkByID(ctx context.Context, id int64) (Chunk, error)
	//GetChunkByNarFileIDAndIndex
	//
	//  SELECT c.id, c.hash, c.size, c.created_at, c.updated_at
	//  FROM chunks c
	//  INNER JOIN nar_file_chunks nfc ON c.id = nfc.chunk_id
	//  WHERE nfc.nar_file_id = ? AND nfc.chunk_index = ?
	GetChunkByNarFileIDAndIndex(ctx context.Context, arg GetChunkByNarFileIDAndIndexParams) (GetChunkByNarFileIDAndIndexRow, error)
	//GetChunkCount
	//
	//  SELECT CAST(COUNT(*) AS SIGNED) AS count
	//  FROM chunks
	GetChunkCount(ctx context.Context) (int64, error)
	//GetChunksByNarFileID
	//
	//  SELECT c.id, c.hash, c.size, c.compressed_size, c.created_at, c.updated_at
	//  FROM chunks c
	//  INNER JOIN nar_file_chunks nfc ON c.id = nfc.chunk_id
	//  WHERE nfc.nar_file_id = ?
	//  ORDER BY nfc.chunk_index
	GetChunksByNarFileID(ctx context.Context, narFileID int64) ([]Chunk, error)
	//GetCompressedNarInfos
	//
	//  SELECT id, hash, created_at, updated_at, last_accessed_at, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, `system`, ca
	//  FROM narinfos
	//  WHERE compression NOT IN ('', 'none')
	//  ORDER BY id
	//  LIMIT ? OFFSET ?
	GetCompressedNarInfos(ctx context.Context, arg GetCompressedNarInfosParams) ([]NarInfo, error)
	//GetConfigByID
	//
	//  SELECT id, `key`, value, created_at, updated_at
	//  FROM config
	//  WHERE id = ?
	GetConfigByID(ctx context.Context, id int64) (Config, error)
	//GetConfigByKey
	//
	//  SELECT id, `key`, value, created_at, updated_at
	//  FROM config
	//  WHERE `key` = ?
	GetConfigByKey(ctx context.Context, key string) (Config, error)
	// NOTE: This query uses a correlated subquery which is not optimal for performance.
	// The ideal implementation would use a window function (SUM OVER), but sqlc v1.30.0
	// does not properly support filtering on window function results in subqueries.
	//
	//  SELECT n1.id, n1.hash, n1.compression, n1.file_size, n1.query, n1.created_at, n1.updated_at, n1.last_accessed_at
	//  FROM nar_files n1
	//  WHERE (
	//      SELECT SUM(n2.file_size)
	//      FROM nar_files n2
	//      WHERE n2.last_accessed_at < n1.last_accessed_at
	//          OR (n2.last_accessed_at = n1.last_accessed_at AND n2.id <= n1.id)
	//  ) <= ?
	GetLeastUsedNarFiles(ctx context.Context, fileSize uint64) ([]GetLeastUsedNarFilesRow, error)
	// NOTE: This query uses a correlated subquery which is not optimal for performance.
	// The ideal implementation would use a window function (SUM OVER), but sqlc v1.30.0
	// does not properly support filtering on window function results in subqueries.
	// Gets the least-used narinfos up to a certain total file size (accounting for their nar_files).
	//
	//  SELECT ni1.id, ni1.hash, ni1.created_at, ni1.updated_at, ni1.last_accessed_at, ni1.store_path, ni1.url, ni1.compression, ni1.file_hash, ni1.file_size, ni1.nar_hash, ni1.nar_size, ni1.deriver, ni1.`system`, ni1.ca
	//  FROM narinfos ni1
	//  WHERE (
	//      SELECT COALESCE(SUM(nf.file_size), 0)
	//      FROM nar_files nf
	//      WHERE nf.id IN (
	//          SELECT DISTINCT nnf.nar_file_id
	//          FROM narinfo_nar_files nnf
	//          INNER JOIN narinfos ni2 ON nnf.narinfo_id = ni2.id
	//          WHERE ni2.last_accessed_at < ni1.last_accessed_at
	//              OR (ni2.last_accessed_at = ni1.last_accessed_at AND ni2.id <= ni1.id)
	//      )
	//  ) <= ?
	GetLeastUsedNarInfos(ctx context.Context, fileSize uint64) ([]NarInfo, error)
	// Get all narinfo hashes that have a URL (migrated).
	//
	//  SELECT hash
	//  FROM narinfos
	//  WHERE url IS NOT NULL
	GetMigratedNarInfoHashes(ctx context.Context) ([]string, error)
	// Get migrated narinfo hashes with pagination support.
	//
	//  SELECT hash
	//  FROM narinfos
	//  WHERE url IS NOT NULL
	//  ORDER BY hash
	//  LIMIT ? OFFSET ?
	GetMigratedNarInfoHashesPaginated(ctx context.Context, arg GetMigratedNarInfoHashesPaginatedParams) ([]string, error)
	//GetNarFileByHashAndCompressionAndQuery
	//
	//  SELECT id, hash, compression, file_size, `query`, created_at, updated_at, last_accessed_at, total_chunks
	//  FROM nar_files
	//  WHERE hash = ? AND compression = ? AND `query` = ?
	GetNarFileByHashAndCompressionAndQuery(ctx context.Context, arg GetNarFileByHashAndCompressionAndQueryParams) (GetNarFileByHashAndCompressionAndQueryRow, error)
	//GetNarFileByID
	//
	//  SELECT id, hash, compression, file_size, `query`, created_at, updated_at, last_accessed_at, total_chunks
	//  FROM nar_files
	//  WHERE id = ?
	GetNarFileByID(ctx context.Context, id int64) (GetNarFileByIDRow, error)
	//GetNarFileByNarInfoID
	//
	//  SELECT nf.id, nf.hash, nf.compression, nf.file_size, nf.query, nf.created_at, nf.updated_at, nf.last_accessed_at
	//  FROM nar_files nf
	//  INNER JOIN narinfo_nar_files nnf ON nf.id = nnf.nar_file_id
	//  WHERE nnf.narinfo_id = ?
	GetNarFileByNarInfoID(ctx context.Context, narinfoID int64) (GetNarFileByNarInfoIDRow, error)
	//GetNarFileCount
	//
	//  SELECT CAST(COUNT(*) AS SIGNED) AS count
	//  FROM nar_files
	GetNarFileCount(ctx context.Context) (int64, error)
	// Get all NAR files that are not yet chunked.
	//
	//  SELECT id, hash, compression, `query`, file_size
	//  FROM nar_files
	//  WHERE total_chunks = 0
	//  ORDER BY id
	GetNarFilesToChunk(ctx context.Context) ([]GetNarFilesToChunkRow, error)
	// Get the count of NAR files that are not yet chunked.
	//
	//  SELECT COUNT(*)
	//  FROM nar_files
	//  WHERE total_chunks = 0
	GetNarFilesToChunkCount(ctx context.Context) (int64, error)
	//GetNarInfoByHash
	//
	//  SELECT id, hash, created_at, updated_at, last_accessed_at, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, `system`, ca
	//  FROM narinfos
	//  WHERE hash = ?
	GetNarInfoByHash(ctx context.Context, hash string) (NarInfo, error)
	//GetNarInfoByID
	//
	//  SELECT id, hash, created_at, updated_at, last_accessed_at, store_path, url, compression, file_hash, file_size, nar_hash, nar_size, deriver, `system`, ca
	//  FROM narinfos
	//  WHERE id = ?
	GetNarInfoByID(ctx context.Context, id int64) (NarInfo, error)
	//GetNarInfoCount
	//
	//  SELECT CAST(COUNT(*) AS SIGNED) AS count
	//  FROM narinfos
	GetNarInfoCount(ctx context.Context) (int64, error)
	//GetNarInfoHashesByNarFileID
	//
	//  SELECT ni.hash
	//  FROM narinfos ni
	//  INNER JOIN narinfo_nar_files nnf ON ni.id = nnf.narinfo_id
	//  WHERE nnf.nar_file_id = ?
	GetNarInfoHashesByNarFileID(ctx context.Context, narFileID int64) ([]string, error)
	//GetNarInfoHashesByURL
	//
	//  SELECT hash
	//  FROM narinfos
	//  WHERE url = ?
	GetNarInfoHashesByURL(ctx context.Context, url sql.NullString) ([]string, error)
	// Get all narinfo hashes that have a URL (migrated) but whose NAR is not yet chunked.
	//
	//  SELECT ni.hash, ni.url
	//  FROM narinfos ni
	//  LEFT JOIN narinfo_nar_files nnf ON ni.id = nnf.narinfo_id
	//  LEFT JOIN nar_files nf ON nnf.nar_file_id = nf.id
	//  WHERE ni.url IS NOT NULL
	//    AND (nf.id IS NULL OR nf.total_chunks = 0)
	//  ORDER BY ni.hash
	GetNarInfoHashesToChunk(ctx context.Context) ([]GetNarInfoHashesToChunkRow, error)
	//GetNarInfoReferences
	//
	//  SELECT reference
	//  FROM narinfo_references
	//  WHERE narinfo_id = ?
	GetNarInfoReferences(ctx context.Context, narinfoID int64) ([]string, error)
	//GetNarInfoSignatures
	//
	//  SELECT signature
	//  FROM narinfo_signatures
	//  WHERE narinfo_id = ?
	GetNarInfoSignatures(ctx context.Context, narinfoID int64) ([]string, error)
	//GetNarInfoURLByNarFileHash
	//
	//  SELECT ni.url
	//  FROM narinfos ni
	//  INNER JOIN narinfo_nar_files nnf ON ni.id = nnf.narinfo_id
	//  INNER JOIN nar_files nf ON nf.id = nnf.nar_file_id
	//  WHERE nf.hash = ? AND nf.compression = ? AND nf.query = ?
	//  LIMIT 1
	GetNarInfoURLByNarFileHash(ctx context.Context, arg GetNarInfoURLByNarFileHashParams) (sql.NullString, error)
	//GetNarTotalSize
	//
	//  SELECT CAST(COALESCE(SUM(file_size), 0) AS SIGNED) AS total_size
	//  FROM nar_files
	GetNarTotalSize(ctx context.Context) (int64, error)
	//GetOldCompressedNarFiles
	//
	//  SELECT id, hash, compression, file_size, `query`, created_at, updated_at, last_accessed_at, total_chunks
	//  FROM nar_files
	//  WHERE compression NOT IN ('', 'none')
	//    AND created_at < ?
	//  ORDER BY id
	//  LIMIT ? OFFSET ?
	GetOldCompressedNarFiles(ctx context.Context, arg GetOldCompressedNarFilesParams) ([]GetOldCompressedNarFilesRow, error)
	//GetOrphanedChunks
	//
	//  SELECT c.id, c.hash, c.size, c.created_at, c.updated_at
	//  FROM chunks c
	//  LEFT JOIN nar_file_chunks nfc ON c.id = nfc.chunk_id
	//  WHERE nfc.chunk_id IS NULL
	GetOrphanedChunks(ctx context.Context) ([]GetOrphanedChunksRow, error)
	// Find files that have no relationship to any narinfo
	//
	//  SELECT nf.id, nf.hash, nf.compression, nf.file_size, nf.query, nf.created_at, nf.updated_at, nf.last_accessed_at
	//  FROM nar_files nf
	//  LEFT JOIN narinfo_nar_files ninf ON nf.id = ninf.nar_file_id
	//  WHERE ninf.narinfo_id IS NULL
	GetOrphanedNarFiles(ctx context.Context) ([]GetOrphanedNarFilesRow, error)
	//GetTotalChunkSize
	//
	//  SELECT CAST(COALESCE(SUM(size), 0) AS SIGNED) AS total_size
	//  FROM chunks
	GetTotalChunkSize(ctx context.Context) (int64, error)
	// Get all narinfo hashes that have no URL (unmigrated).
	//
	//  SELECT hash
	//  FROM narinfos
	//  WHERE url IS NULL
	GetUnmigratedNarInfoHashes(ctx context.Context) ([]string, error)
	// Check if a narinfo hash has been migrated (has a URL).
	//
	//  SELECT EXISTS(
	//      SELECT 1
	//      FROM narinfos
	//      WHERE hash = ? AND url IS NOT NULL
	//  ) AS is_migrated
	IsNarInfoMigrated(ctx context.Context, hash string) (bool, error)
	//LinkNarFileToChunk
	//
	//  INSERT IGNORE INTO nar_file_chunks (
	//      nar_file_id, chunk_id, chunk_index
	//  ) VALUES (
	//      ?, ?, ?
	//  )
	LinkNarFileToChunk(ctx context.Context, arg LinkNarFileToChunkParams) error
	// @bulk-for LinkNarFileToChunk
	//
	//  INSERT IGNORE INTO nar_file_chunks (
	//      nar_file_id, chunk_id, chunk_index
	//  ) VALUES (
	//      ?, ?, ?
	//  )
	LinkNarFileToChunks(ctx context.Context, arg LinkNarFileToChunksParams) error
	//LinkNarInfoToNarFile
	//
	//  INSERT INTO narinfo_nar_files (
	//      narinfo_id, nar_file_id
	//  ) VALUES (
	//      ?, ?
	//  )
	//  ON DUPLICATE KEY UPDATE narinfo_id = narinfo_id
	LinkNarInfoToNarFile(ctx context.Context, arg LinkNarInfoToNarFileParams) error
	//LinkNarInfosByURLToNarFile
	//
	//  INSERT IGNORE INTO narinfo_nar_files (narinfo_id, nar_file_id)
	//  SELECT id, ?
	//  FROM narinfos
	//  WHERE url = ?
	LinkNarInfosByURLToNarFile(ctx context.Context, arg LinkNarInfosByURLToNarFileParams) error
	//SetConfig
	//
	//  INSERT INTO config (
	//      `key`, value
	//  ) VALUES (
	//      ?, ?
	//  )
	//  ON DUPLICATE KEY UPDATE
	//      value = VALUES(value),
	//      updated_at = CURRENT_TIMESTAMP
	SetConfig(ctx context.Context, arg SetConfigParams) error
	//TouchNarFile
	//
	//  UPDATE nar_files
	//  SET
	//      last_accessed_at = CURRENT_TIMESTAMP,
	//      updated_at = CURRENT_TIMESTAMP
	//  WHERE hash = ? AND compression = ? AND `query` = ?
	TouchNarFile(ctx context.Context, arg TouchNarFileParams) (int64, error)
	//TouchNarInfo
	//
	//  UPDATE narinfos
	//  SET
	//      last_accessed_at = CURRENT_TIMESTAMP,
	//      updated_at = CURRENT_TIMESTAMP
	//  WHERE hash = ?
	TouchNarInfo(ctx context.Context, hash string) (int64, error)
	//UpdateNarFileFileSize
	//
	//  UPDATE nar_files
	//  SET file_size = ?, updated_at = CURRENT_TIMESTAMP
	//  WHERE id = ?
	UpdateNarFileFileSize(ctx context.Context, arg UpdateNarFileFileSizeParams) error
	//UpdateNarFileTotalChunks
	//
	//  UPDATE nar_files
	//  SET total_chunks = ?, file_size = ?, updated_at = CURRENT_TIMESTAMP
	//  WHERE id = ?
	UpdateNarFileTotalChunks(ctx context.Context, arg UpdateNarFileTotalChunksParams) error
	//UpdateNarInfo
	//
	//  UPDATE narinfos
	//  SET
	//      store_path = ?,
	//      url = ?,
	//      compression = ?,
	//      file_hash = ?,
	//      file_size = ?,
	//      nar_hash = ?,
	//      nar_size = ?,
	//      deriver = ?,
	//      system = ?,
	//      ca = ?,
	//      updated_at = CURRENT_TIMESTAMP
	//  WHERE hash = ?
	UpdateNarInfo(ctx context.Context, arg UpdateNarInfoParams) (sql.Result, error)
	// Update narinfo compression and URL after CDC migration.
	//
	//  UPDATE narinfos
	//  SET compression = ?, url = ?, updated_at = CURRENT_TIMESTAMP
	//  WHERE url = ?
	UpdateNarInfoCompressionAndURL(ctx context.Context, arg UpdateNarInfoCompressionAndURLParams) (int64, error)
	//UpdateNarInfoFileHash
	//
	//  UPDATE narinfos
	//  SET file_hash = ?, updated_at = CURRENT_TIMESTAMP
	//  WHERE hash = ?
	UpdateNarInfoFileHash(ctx context.Context, arg UpdateNarInfoFileHashParams) error
	//UpdateNarInfoFileSize
	//
	//  UPDATE narinfos
	//  SET file_size = ?, updated_at = CURRENT_TIMESTAMP
	//  WHERE hash = ?
	UpdateNarInfoFileSize(ctx context.Context, arg UpdateNarInfoFileSizeParams) error
}

var _ Querier = (*Queries)(nil)
