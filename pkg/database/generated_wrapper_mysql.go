// Code generated by gen-db-wrappers. DO NOT EDIT.
package database

import (
	"context"
	"database/sql"
	"errors"

	"github.com/kalbasit/ncps/pkg/database/mysqldb"
)

// mysqlWrapper wraps the mysql adapter.
type mysqlWrapper struct {
	adapter *mysqldb.Adapter
}

func (w *mysqlWrapper) AddNarInfoReference(ctx context.Context, arg AddNarInfoReferenceParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.AddNarInfoReference(ctx, mysqldb.AddNarInfoReferenceParams{
		NarInfoID: arg.NarInfoID,
		Reference: arg.Reference,
	})
}

func (w *mysqlWrapper) AddNarInfoReferences(ctx context.Context, arg AddNarInfoReferencesParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	for i, v := range arg.Reference {
		_ = i
		err := w.adapter.AddNarInfoReference(ctx, mysqldb.AddNarInfoReferenceParams{
			NarInfoID: arg.NarInfoID,

			Reference: v,
		},
		)
		if err != nil {
			return err
		}
	}
	return nil
}

func (w *mysqlWrapper) AddNarInfoSignature(ctx context.Context, arg AddNarInfoSignatureParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.AddNarInfoSignature(ctx, mysqldb.AddNarInfoSignatureParams{
		NarInfoID: arg.NarInfoID,
		Signature: arg.Signature,
	})
}

func (w *mysqlWrapper) AddNarInfoSignatures(ctx context.Context, arg AddNarInfoSignaturesParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	for i, v := range arg.Signature {
		_ = i
		err := w.adapter.AddNarInfoSignature(ctx, mysqldb.AddNarInfoSignatureParams{
			NarInfoID: arg.NarInfoID,

			Signature: v,
		},
		)
		if err != nil {
			return err
		}
	}
	return nil
}

func (w *mysqlWrapper) CreateChunk(ctx context.Context, arg CreateChunkParams) (Chunk, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	// MySQL does not support RETURNING for INSERTs.
	// We insert, get LastInsertId, and then fetch the object.
	res, err := w.adapter.CreateChunk(ctx, mysqldb.CreateChunkParams{
		Hash:           arg.Hash,
		Size:           arg.Size,
		CompressedSize: arg.CompressedSize,
	})
	if err != nil {
		return Chunk{}, err
	}

	id, err := res.LastInsertId()
	if err != nil {
		return Chunk{}, err
	}

	nf, err := w.GetChunkByID(ctx, id)
	if err == nil {
		return nf, nil
	}
	if !errors.Is(err, ErrNotFound) {
		return Chunk{}, err
	}

	// MySQL REPEATABLE READ: if ON DUPLICATE KEY UPDATE fired (another transaction
	// already committed this row), the current transaction's MVCC snapshot may not
	// see it via GetByID. Fall back to a non-transactional lookup on the raw DB
	// connection, which always reads the latest committed data.
	return (&mysqlWrapper{adapter: mysqldb.NewAdapter(w.adapter.DB())}).GetChunkByID(ctx, id)
}

func (w *mysqlWrapper) CreateConfig(ctx context.Context, arg CreateConfigParams) (Config, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	// MySQL does not support RETURNING for INSERTs.
	// We insert, get LastInsertId, and then fetch the object.
	res, err := w.adapter.CreateConfig(ctx, mysqldb.CreateConfigParams{
		Key:   arg.Key,
		Value: arg.Value,
	})
	if err != nil {
		return Config{}, err
	}

	id, err := res.LastInsertId()
	if err != nil {
		return Config{}, err
	}

	nf, err := w.GetConfigByID(ctx, id)
	if err == nil {
		return nf, nil
	}
	if !errors.Is(err, ErrNotFound) {
		return Config{}, err
	}

	// MySQL REPEATABLE READ: if ON DUPLICATE KEY UPDATE fired (another transaction
	// already committed this row), the current transaction's MVCC snapshot may not
	// see it via GetByID. Fall back to a non-transactional lookup on the raw DB
	// connection, which always reads the latest committed data.
	return (&mysqlWrapper{adapter: mysqldb.NewAdapter(w.adapter.DB())}).GetConfigByID(ctx, id)
}

func (w *mysqlWrapper) CreateNarFile(ctx context.Context, arg CreateNarFileParams) (NarFile, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	// MySQL does not support RETURNING for INSERTs.
	// We insert, get LastInsertId, and then fetch the object.
	res, err := w.adapter.CreateNarFile(ctx, mysqldb.CreateNarFileParams{
		Hash:        arg.Hash,
		Compression: arg.Compression,
		Query:       arg.Query,
		FileSize:    arg.FileSize,
		TotalChunks: arg.TotalChunks,
	})
	if err != nil {
		return NarFile{}, err
	}

	id, err := res.LastInsertId()
	if err != nil {
		return NarFile{}, err
	}

	nf, err := w.GetNarFileByID(ctx, id)
	if err == nil {
		return nf, nil
	}
	if !errors.Is(err, ErrNotFound) {
		return NarFile{}, err
	}

	// MySQL REPEATABLE READ: if ON DUPLICATE KEY UPDATE fired (another transaction
	// already committed this row), the current transaction's MVCC snapshot may not
	// see it via GetByID. Fall back to a non-transactional lookup on the raw DB
	// connection, which always reads the latest committed data.
	return (&mysqlWrapper{adapter: mysqldb.NewAdapter(w.adapter.DB())}).GetNarFileByID(ctx, id)
}

func (w *mysqlWrapper) CreateNarInfo(ctx context.Context, arg CreateNarInfoParams) (NarInfo, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	// MySQL does not support RETURNING for INSERTs.
	// We insert, get LastInsertId, and then fetch the object.
	res, err := w.adapter.CreateNarInfo(ctx, mysqldb.CreateNarInfoParams{
		Hash:        arg.Hash,
		StorePath:   arg.StorePath,
		URL:         arg.URL,
		Compression: arg.Compression,
		FileHash:    arg.FileHash,
		FileSize:    arg.FileSize,
		NarHash:     arg.NarHash,
		NarSize:     arg.NarSize,
		Deriver:     arg.Deriver,
		System:      arg.System,
		Ca:          arg.Ca,
	})
	if err != nil {
		return NarInfo{}, err
	}

	id, err := res.LastInsertId()
	if err != nil {
		return NarInfo{}, err
	}

	nf, err := w.GetNarInfoByID(ctx, id)
	if err == nil {
		return nf, nil
	}
	if !errors.Is(err, ErrNotFound) {
		return NarInfo{}, err
	}

	// MySQL REPEATABLE READ: if ON DUPLICATE KEY UPDATE fired (another transaction
	// already committed this row), the current transaction's MVCC snapshot may not
	// see it via GetByID. Fall back to a non-transactional lookup on the raw DB
	// connection, which always reads the latest committed data.
	return (&mysqlWrapper{adapter: mysqldb.NewAdapter(w.adapter.DB())}).GetNarInfoByID(ctx, id)
}

func (w *mysqlWrapper) DeleteChunkByID(ctx context.Context, id int64) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.DeleteChunkByID(ctx, id)
}

func (w *mysqlWrapper) DeleteNarFileByHash(ctx context.Context, arg DeleteNarFileByHashParams) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.DeleteNarFileByHash(ctx, mysqldb.DeleteNarFileByHashParams{
		Hash:        arg.Hash,
		Compression: arg.Compression,
		Query:       arg.Query,
	})
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) DeleteNarFileByID(ctx context.Context, id int64) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.DeleteNarFileByID(ctx, id)
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) DeleteNarFileChunksByNarFileID(ctx context.Context, narFileID int64) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.DeleteNarFileChunksByNarFileID(ctx, narFileID)
}

func (w *mysqlWrapper) DeleteNarInfoByHash(ctx context.Context, hash string) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.DeleteNarInfoByHash(ctx, hash)
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) DeleteNarInfoByID(ctx context.Context, id int64) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.DeleteNarInfoByID(ctx, id)
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) DeleteOrphanedChunks(ctx context.Context) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.DeleteOrphanedChunks(ctx)
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) DeleteOrphanedNarFiles(ctx context.Context) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.DeleteOrphanedNarFiles(ctx)
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) DeleteOrphanedNarInfos(ctx context.Context) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.DeleteOrphanedNarInfos(ctx)
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) GetChunkByHash(ctx context.Context, hash string) (Chunk, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetChunkByHash(ctx, hash)
	if err != nil {

		if errors.Is(err, sql.ErrNoRows) {
			return Chunk{}, ErrNotFound
		}

		return Chunk{}, err
	}

	// Convert Single Domain Struct

	return Chunk{
		ID: res.ID,

		Hash: res.Hash,

		Size: res.Size,

		CompressedSize: res.CompressedSize,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *mysqlWrapper) GetChunkByID(ctx context.Context, id int64) (Chunk, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	query := "SELECT `id`, `hash`, `size`, `compressed_size`, `created_at`, `updated_at` FROM chunks WHERE id = ?"
	row := w.adapter.DBTX().QueryRowContext(ctx, query, id)
	var res mysqldb.Chunk
	err := row.Scan(

		&res.ID,

		&res.Hash,

		&res.Size,

		&res.CompressedSize,

		&res.CreatedAt,

		&res.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return Chunk{}, ErrNotFound
		}
		return Chunk{}, err
	}

	// Convert to Domain Struct

	return Chunk{
		ID: res.ID,

		Hash: res.Hash,

		Size: res.Size,

		CompressedSize: res.CompressedSize,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *mysqlWrapper) GetChunkByNarFileIDAndIndex(ctx context.Context, arg GetChunkByNarFileIDAndIndexParams) (GetChunkByNarFileIDAndIndexRow, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetChunkByNarFileIDAndIndex(ctx, mysqldb.GetChunkByNarFileIDAndIndexParams{
		NarFileID:  arg.NarFileID,
		ChunkIndex: arg.ChunkIndex,
	})
	if err != nil {

		if errors.Is(err, sql.ErrNoRows) {
			return GetChunkByNarFileIDAndIndexRow{}, ErrNotFound
		}

		return GetChunkByNarFileIDAndIndexRow{}, err
	}

	// Convert Single Domain Struct

	return GetChunkByNarFileIDAndIndexRow{
		ID: res.ID,

		Hash: res.Hash,

		Size: res.Size,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *mysqlWrapper) GetChunkCount(ctx context.Context) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetChunkCount(ctx)
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) GetChunksByNarFileID(ctx context.Context, narFileID int64) ([]Chunk, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetChunksByNarFileID(ctx, narFileID)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]Chunk, len(res))
	for i, v := range res {
		items[i] = Chunk{
			ID: v.ID,

			Hash: v.Hash,

			Size: v.Size,

			CompressedSize: v.CompressedSize,

			CreatedAt: v.CreatedAt,

			UpdatedAt: v.UpdatedAt,
		}
	}
	return items, nil
}

func (w *mysqlWrapper) GetCompressedNarInfos(ctx context.Context, arg GetCompressedNarInfosParams) ([]NarInfo, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetCompressedNarInfos(ctx, mysqldb.GetCompressedNarInfosParams{
		Limit:  arg.Limit,
		Offset: arg.Offset,
	})
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]NarInfo, len(res))
	for i, v := range res {
		items[i] = NarInfo{
			ID: v.ID,

			Hash: v.Hash,

			CreatedAt: v.CreatedAt,

			UpdatedAt: v.UpdatedAt,

			LastAccessedAt: v.LastAccessedAt,

			StorePath: v.StorePath,

			URL: v.URL,

			Compression: v.Compression,

			FileHash: v.FileHash,

			FileSize: v.FileSize,

			NarHash: v.NarHash,

			NarSize: v.NarSize,

			Deriver: v.Deriver,

			System: v.System,

			Ca: v.Ca,
		}
	}
	return items, nil
}

func (w *mysqlWrapper) GetConfigByID(ctx context.Context, id int64) (Config, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	query := "SELECT `id`, `key`, `value`, `created_at`, `updated_at` FROM config WHERE id = ?"
	row := w.adapter.DBTX().QueryRowContext(ctx, query, id)
	var res mysqldb.Config
	err := row.Scan(

		&res.ID,

		&res.Key,

		&res.Value,

		&res.CreatedAt,

		&res.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return Config{}, ErrNotFound
		}
		return Config{}, err
	}

	// Convert to Domain Struct

	return Config{
		ID: res.ID,

		Key: res.Key,

		Value: res.Value,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *mysqlWrapper) GetConfigByKey(ctx context.Context, key string) (Config, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetConfigByKey(ctx, key)
	if err != nil {

		if errors.Is(err, sql.ErrNoRows) {
			return Config{}, ErrNotFound
		}

		return Config{}, err
	}

	// Convert Single Domain Struct

	return Config{
		ID: res.ID,

		Key: res.Key,

		Value: res.Value,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *mysqlWrapper) GetLeastUsedNarFiles(ctx context.Context, fileSize uint64) ([]NarFile, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetLeastUsedNarFiles(ctx, fileSize)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]NarFile, len(res))
	for i, v := range res {
		items[i] = NarFile{
			ID: v.ID,

			Hash: v.Hash,

			Compression: v.Compression,

			FileSize: v.FileSize,

			Query: v.Query,

			CreatedAt: v.CreatedAt,

			UpdatedAt: v.UpdatedAt,

			LastAccessedAt: v.LastAccessedAt,

			TotalChunks: v.TotalChunks,

			ChunkingStartedAt: v.ChunkingStartedAt,
		}
	}
	return items, nil
}

func (w *mysqlWrapper) GetLeastUsedNarInfos(ctx context.Context, fileSize uint64) ([]NarInfo, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetLeastUsedNarInfos(ctx, fileSize)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]NarInfo, len(res))
	for i, v := range res {
		items[i] = NarInfo{
			ID: v.ID,

			Hash: v.Hash,

			CreatedAt: v.CreatedAt,

			UpdatedAt: v.UpdatedAt,

			LastAccessedAt: v.LastAccessedAt,

			StorePath: v.StorePath,

			URL: v.URL,

			Compression: v.Compression,

			FileHash: v.FileHash,

			FileSize: v.FileSize,

			NarHash: v.NarHash,

			NarSize: v.NarSize,

			Deriver: v.Deriver,

			System: v.System,

			Ca: v.Ca,
		}
	}
	return items, nil
}

func (w *mysqlWrapper) GetMigratedNarInfoHashes(ctx context.Context) ([]string, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetMigratedNarInfoHashes(ctx)
	if err != nil {
		return nil, err
	}

	// Return Slice of Primitives (direct match)
	return res, nil
}

func (w *mysqlWrapper) GetMigratedNarInfoHashesPaginated(ctx context.Context, arg GetMigratedNarInfoHashesPaginatedParams) ([]string, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetMigratedNarInfoHashesPaginated(ctx, mysqldb.GetMigratedNarInfoHashesPaginatedParams{
		Limit:  arg.Limit,
		Offset: arg.Offset,
	})
	if err != nil {
		return nil, err
	}

	// Return Slice of Primitives (direct match)
	return res, nil
}

func (w *mysqlWrapper) GetNarFileByHashAndCompressionAndQuery(ctx context.Context, arg GetNarFileByHashAndCompressionAndQueryParams) (NarFile, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetNarFileByHashAndCompressionAndQuery(ctx, mysqldb.GetNarFileByHashAndCompressionAndQueryParams{
		Hash:        arg.Hash,
		Compression: arg.Compression,
		Query:       arg.Query,
	})
	if err != nil {

		if errors.Is(err, sql.ErrNoRows) {
			return NarFile{}, ErrNotFound
		}

		return NarFile{}, err
	}

	// Convert Single Domain Struct

	return NarFile{
		ID: res.ID,

		Hash: res.Hash,

		Compression: res.Compression,

		FileSize: res.FileSize,

		Query: res.Query,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,

		LastAccessedAt: res.LastAccessedAt,

		TotalChunks: res.TotalChunks,

		ChunkingStartedAt: res.ChunkingStartedAt,
	}, nil
}

func (w *mysqlWrapper) GetNarFileByID(ctx context.Context, id int64) (NarFile, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	query := "SELECT `id`, `hash`, `compression`, `file_size`, `created_at`, `updated_at`, `last_accessed_at`, `query`, `total_chunks`, `chunking_started_at` FROM nar_files WHERE id = ?"
	row := w.adapter.DBTX().QueryRowContext(ctx, query, id)
	var res mysqldb.NarFile
	err := row.Scan(

		&res.ID,

		&res.Hash,

		&res.Compression,

		&res.FileSize,

		&res.CreatedAt,

		&res.UpdatedAt,

		&res.LastAccessedAt,

		&res.Query,

		&res.TotalChunks,

		&res.ChunkingStartedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return NarFile{}, ErrNotFound
		}
		return NarFile{}, err
	}

	// Convert to Domain Struct

	return NarFile{
		ID: res.ID,

		Hash: res.Hash,

		Compression: res.Compression,

		FileSize: res.FileSize,

		Query: res.Query,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,

		LastAccessedAt: res.LastAccessedAt,

		TotalChunks: res.TotalChunks,

		ChunkingStartedAt: res.ChunkingStartedAt,
	}, nil
}

func (w *mysqlWrapper) GetNarFileByNarInfoID(ctx context.Context, narinfoID int64) (NarFile, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetNarFileByNarInfoID(ctx, narinfoID)
	if err != nil {

		if errors.Is(err, sql.ErrNoRows) {
			return NarFile{}, ErrNotFound
		}

		return NarFile{}, err
	}

	// Convert Single Domain Struct

	return NarFile{
		ID: res.ID,

		Hash: res.Hash,

		Compression: res.Compression,

		FileSize: res.FileSize,

		Query: res.Query,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,

		LastAccessedAt: res.LastAccessedAt,

		TotalChunks: res.TotalChunks,

		ChunkingStartedAt: res.ChunkingStartedAt,
	}, nil
}

func (w *mysqlWrapper) GetNarFileCount(ctx context.Context) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetNarFileCount(ctx)
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) GetNarFilesToChunk(ctx context.Context) ([]GetNarFilesToChunkRow, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetNarFilesToChunk(ctx)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]GetNarFilesToChunkRow, len(res))
	for i, v := range res {
		items[i] = GetNarFilesToChunkRow{
			ID: v.ID,

			Hash: v.Hash,

			Compression: v.Compression,

			Query: v.Query,

			FileSize: v.FileSize,
		}
	}
	return items, nil
}

func (w *mysqlWrapper) GetNarFilesToChunkCount(ctx context.Context) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetNarFilesToChunkCount(ctx)
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) GetNarInfoByHash(ctx context.Context, hash string) (NarInfo, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetNarInfoByHash(ctx, hash)
	if err != nil {

		if errors.Is(err, sql.ErrNoRows) {
			return NarInfo{}, ErrNotFound
		}

		return NarInfo{}, err
	}

	// Convert Single Domain Struct

	return NarInfo{
		ID: res.ID,

		Hash: res.Hash,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,

		LastAccessedAt: res.LastAccessedAt,

		StorePath: res.StorePath,

		URL: res.URL,

		Compression: res.Compression,

		FileHash: res.FileHash,

		FileSize: res.FileSize,

		NarHash: res.NarHash,

		NarSize: res.NarSize,

		Deriver: res.Deriver,

		System: res.System,

		Ca: res.Ca,
	}, nil
}

func (w *mysqlWrapper) GetNarInfoByID(ctx context.Context, id int64) (NarInfo, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	query := "SELECT `id`, `hash`, `created_at`, `updated_at`, `last_accessed_at`, `store_path`, `url`, `compression`, `file_hash`, `file_size`, `nar_hash`, `nar_size`, `deriver`, `system`, `ca` FROM narinfos WHERE id = ?"
	row := w.adapter.DBTX().QueryRowContext(ctx, query, id)
	var res mysqldb.NarInfo
	err := row.Scan(

		&res.ID,

		&res.Hash,

		&res.CreatedAt,

		&res.UpdatedAt,

		&res.LastAccessedAt,

		&res.StorePath,

		&res.URL,

		&res.Compression,

		&res.FileHash,

		&res.FileSize,

		&res.NarHash,

		&res.NarSize,

		&res.Deriver,

		&res.System,

		&res.Ca,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return NarInfo{}, ErrNotFound
		}
		return NarInfo{}, err
	}

	// Convert to Domain Struct

	return NarInfo{
		ID: res.ID,

		Hash: res.Hash,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,

		LastAccessedAt: res.LastAccessedAt,

		StorePath: res.StorePath,

		URL: res.URL,

		Compression: res.Compression,

		FileHash: res.FileHash,

		FileSize: res.FileSize,

		NarHash: res.NarHash,

		NarSize: res.NarSize,

		Deriver: res.Deriver,

		System: res.System,

		Ca: res.Ca,
	}, nil
}

func (w *mysqlWrapper) GetNarInfoCount(ctx context.Context) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetNarInfoCount(ctx)
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) GetNarInfoHashByNarURL(ctx context.Context, url sql.NullString) (string, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetNarInfoHashByNarURL(ctx, url)
	if err != nil {
		return "", err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) GetNarInfoHashesByNarFileID(ctx context.Context, narFileID int64) ([]string, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetNarInfoHashesByNarFileID(ctx, narFileID)
	if err != nil {
		return nil, err
	}

	// Return Slice of Primitives (direct match)
	return res, nil
}

func (w *mysqlWrapper) GetNarInfoHashesByURL(ctx context.Context, url sql.NullString) ([]string, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetNarInfoHashesByURL(ctx, url)
	if err != nil {
		return nil, err
	}

	// Return Slice of Primitives (direct match)
	return res, nil
}

func (w *mysqlWrapper) GetNarInfoHashesToChunk(ctx context.Context) ([]GetNarInfoHashesToChunkRow, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetNarInfoHashesToChunk(ctx)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]GetNarInfoHashesToChunkRow, len(res))
	for i, v := range res {
		items[i] = GetNarInfoHashesToChunkRow{
			Hash: v.Hash,

			URL: v.URL,
		}
	}
	return items, nil
}

func (w *mysqlWrapper) GetNarInfoReferences(ctx context.Context, narinfoID int64) ([]string, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetNarInfoReferences(ctx, narinfoID)
	if err != nil {
		return nil, err
	}

	// Return Slice of Primitives (direct match)
	return res, nil
}

func (w *mysqlWrapper) GetNarInfoSignatures(ctx context.Context, narinfoID int64) ([]string, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetNarInfoSignatures(ctx, narinfoID)
	if err != nil {
		return nil, err
	}

	// Return Slice of Primitives (direct match)
	return res, nil
}

func (w *mysqlWrapper) GetNarInfoURLByNarFileHash(ctx context.Context, arg GetNarInfoURLByNarFileHashParams) (sql.NullString, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetNarInfoURLByNarFileHash(ctx, mysqldb.GetNarInfoURLByNarFileHashParams{
		Hash:        arg.Hash,
		Compression: arg.Compression,
		Query:       arg.Query,
	})
	if err != nil {
		return sql.NullString{}, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) GetNarTotalSize(ctx context.Context) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetNarTotalSize(ctx)
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) GetOldCompressedNarFiles(ctx context.Context, arg GetOldCompressedNarFilesParams) ([]NarFile, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetOldCompressedNarFiles(ctx, mysqldb.GetOldCompressedNarFilesParams{
		CreatedAt: arg.CreatedAt,
		Limit:     arg.Limit,
		Offset:    arg.Offset,
	})
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]NarFile, len(res))
	for i, v := range res {
		items[i] = NarFile{
			ID: v.ID,

			Hash: v.Hash,

			Compression: v.Compression,

			FileSize: v.FileSize,

			Query: v.Query,

			CreatedAt: v.CreatedAt,

			UpdatedAt: v.UpdatedAt,

			LastAccessedAt: v.LastAccessedAt,

			TotalChunks: v.TotalChunks,

			ChunkingStartedAt: v.ChunkingStartedAt,
		}
	}
	return items, nil
}

func (w *mysqlWrapper) GetOrphanedChunks(ctx context.Context) ([]GetOrphanedChunksRow, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetOrphanedChunks(ctx)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]GetOrphanedChunksRow, len(res))
	for i, v := range res {
		items[i] = GetOrphanedChunksRow{
			ID: v.ID,

			Hash: v.Hash,

			Size: v.Size,

			CreatedAt: v.CreatedAt,

			UpdatedAt: v.UpdatedAt,
		}
	}
	return items, nil
}

func (w *mysqlWrapper) GetOrphanedNarFiles(ctx context.Context) ([]NarFile, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetOrphanedNarFiles(ctx)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]NarFile, len(res))
	for i, v := range res {
		items[i] = NarFile{
			ID: v.ID,

			Hash: v.Hash,

			Compression: v.Compression,

			FileSize: v.FileSize,

			Query: v.Query,

			CreatedAt: v.CreatedAt,

			UpdatedAt: v.UpdatedAt,

			LastAccessedAt: v.LastAccessedAt,

			TotalChunks: v.TotalChunks,

			ChunkingStartedAt: v.ChunkingStartedAt,
		}
	}
	return items, nil
}

func (w *mysqlWrapper) GetTotalChunkSize(ctx context.Context) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetTotalChunkSize(ctx)
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) GetUnmigratedNarInfoHashes(ctx context.Context) ([]string, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetUnmigratedNarInfoHashes(ctx)
	if err != nil {
		return nil, err
	}

	// Return Slice of Primitives (direct match)
	return res, nil
}

func (w *mysqlWrapper) IsNarInfoMigrated(ctx context.Context, hash string) (bool, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.IsNarInfoMigrated(ctx, hash)
	if err != nil {
		return false, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) LinkNarFileToChunk(ctx context.Context, arg LinkNarFileToChunkParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.LinkNarFileToChunk(ctx, mysqldb.LinkNarFileToChunkParams{
		NarFileID:  arg.NarFileID,
		ChunkID:    arg.ChunkID,
		ChunkIndex: arg.ChunkIndex,
	})
}

func (w *mysqlWrapper) LinkNarFileToChunks(ctx context.Context, arg LinkNarFileToChunksParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	if len(arg.ChunkIndex) != len(arg.ChunkID) {
		return ErrMismatchedSlices
	}
	for i, v := range arg.ChunkID {
		_ = i
		err := w.adapter.LinkNarFileToChunk(ctx, mysqldb.LinkNarFileToChunkParams{
			NarFileID: arg.NarFileID,

			ChunkID: v,

			ChunkIndex: arg.ChunkIndex[i],
		},
		)
		if err != nil {
			return err
		}
	}
	return nil
}

func (w *mysqlWrapper) LinkNarInfoToNarFile(ctx context.Context, arg LinkNarInfoToNarFileParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.LinkNarInfoToNarFile(ctx, mysqldb.LinkNarInfoToNarFileParams{
		NarInfoID: arg.NarInfoID,
		NarFileID: arg.NarFileID,
	})
}

func (w *mysqlWrapper) LinkNarInfosByURLToNarFile(ctx context.Context, arg LinkNarInfosByURLToNarFileParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.LinkNarInfosByURLToNarFile(ctx, mysqldb.LinkNarInfosByURLToNarFileParams{
		NarFileID: arg.NarFileID,
		URL:       arg.URL,
	})
}

func (w *mysqlWrapper) SetConfig(ctx context.Context, arg SetConfigParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.SetConfig(ctx, mysqldb.SetConfigParams{
		Key:   arg.Key,
		Value: arg.Value,
	})
}

func (w *mysqlWrapper) SetNarFileChunkingStarted(ctx context.Context, id int64) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.SetNarFileChunkingStarted(ctx, id)
}

func (w *mysqlWrapper) TouchNarFile(ctx context.Context, arg TouchNarFileParams) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.TouchNarFile(ctx, mysqldb.TouchNarFileParams{
		Hash:        arg.Hash,
		Compression: arg.Compression,
		Query:       arg.Query,
	})
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) TouchNarInfo(ctx context.Context, hash string) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.TouchNarInfo(ctx, hash)
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) UpdateNarFileFileSize(ctx context.Context, arg UpdateNarFileFileSizeParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.UpdateNarFileFileSize(ctx, mysqldb.UpdateNarFileFileSizeParams{
		FileSize: arg.FileSize,
		ID:       arg.ID,
	})
}

func (w *mysqlWrapper) UpdateNarFileTotalChunks(ctx context.Context, arg UpdateNarFileTotalChunksParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.UpdateNarFileTotalChunks(ctx, mysqldb.UpdateNarFileTotalChunksParams{
		TotalChunks: arg.TotalChunks,
		FileSize:    arg.FileSize,
		ID:          arg.ID,
	})
}

func (w *mysqlWrapper) UpdateNarInfo(ctx context.Context, arg UpdateNarInfoParams) (NarInfo, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	// MySQL does not support RETURNING for UPDATEs.
	// We update, and then fetch the object by its unique key (assumed to be the first param after context, or we try by Hash if it exists).
	res, err := w.adapter.UpdateNarInfo(ctx, mysqldb.UpdateNarInfoParams{
		StorePath:   arg.StorePath,
		URL:         arg.URL,
		Compression: arg.Compression,
		FileHash:    arg.FileHash,
		FileSize:    arg.FileSize,
		NarHash:     arg.NarHash,
		NarSize:     arg.NarSize,
		Deriver:     arg.Deriver,
		System:      arg.System,
		Ca:          arg.Ca,
		Hash:        arg.Hash,
	})
	if err != nil {
		return NarInfo{}, err
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return NarInfo{}, err
	}
	if rowsAffected == 0 {
		return NarInfo{}, ErrNotFound
	}

	return w.GetNarInfoByHash(ctx, arg.Hash)
}

func (w *mysqlWrapper) UpdateNarInfoCompressionAndURL(ctx context.Context, arg UpdateNarInfoCompressionAndURLParams) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.UpdateNarInfoCompressionAndURL(ctx, mysqldb.UpdateNarInfoCompressionAndURLParams{
		Compression: arg.Compression,
		NewUrl:      arg.NewUrl,
		OldUrl:      arg.OldUrl,
	})
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) UpdateNarInfoCompressionFileSizeHashAndURL(ctx context.Context, arg UpdateNarInfoCompressionFileSizeHashAndURLParams) (int64, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.UpdateNarInfoCompressionFileSizeHashAndURL(ctx, mysqldb.UpdateNarInfoCompressionFileSizeHashAndURLParams{
		Compression: arg.Compression,
		NewUrl:      arg.NewUrl,
		FileSize:    arg.FileSize,
		FileHash:    arg.FileHash,
		OldUrl:      arg.OldUrl,
	})
	if err != nil {
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) UpdateNarInfoFileHash(ctx context.Context, arg UpdateNarInfoFileHashParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.UpdateNarInfoFileHash(ctx, mysqldb.UpdateNarInfoFileHashParams{
		FileHash: arg.FileHash,
		Hash:     arg.Hash,
	})
}

func (w *mysqlWrapper) UpdateNarInfoFileSize(ctx context.Context, arg UpdateNarInfoFileSizeParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.UpdateNarInfoFileSize(ctx, mysqldb.UpdateNarInfoFileSizeParams{
		FileSize: arg.FileSize,
		Hash:     arg.Hash,
	})
}

func (w *mysqlWrapper) WithTx(tx *sql.Tx) Querier {
	res := w.adapter.WithTx(tx)
	return &mysqlWrapper{adapter: res}
}

func (w *mysqlWrapper) DB() *sql.DB {
	return w.adapter.DB()
}
