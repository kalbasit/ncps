// Code generated by gen-db-wrappers. DO NOT EDIT.
package database

import (
	"context"
	"database/sql"

	"github.com/kalbasit/ncps/pkg/database/mysqldb"
)

// mysqlWrapper wraps the mysql adapter.
type mysqlWrapper struct {
	adapter *mysqldb.Adapter
}

func (w *mysqlWrapper) AddNarInfoReference(ctx context.Context, arg AddNarInfoReferenceParams) error {
	err := w.adapter.AddNarInfoReference(ctx, mysqldb.AddNarInfoReferenceParams(arg))
	if err != nil {
		return err
	}

	// No return value (void)
	return nil
}

func (w *mysqlWrapper) AddNarInfoReferences(ctx context.Context, arg AddNarInfoReferencesParams) error {
	for _, v := range arg.Reference {
		err := w.adapter.AddNarInfoReference(ctx, mysqldb.AddNarInfoReferenceParams{
			NarInfoID: arg.NarInfoID,
			Reference: v,
		})
		if err != nil {
			if IsDuplicateKeyError(err) {
				continue
			}
			return err
		}
	}
	return nil
}

func (w *mysqlWrapper) AddNarInfoSignature(ctx context.Context, arg AddNarInfoSignatureParams) error {
	err := w.adapter.AddNarInfoSignature(ctx, mysqldb.AddNarInfoSignatureParams(arg))
	if err != nil {
		return err
	}

	// No return value (void)
	return nil
}

func (w *mysqlWrapper) AddNarInfoSignatures(ctx context.Context, arg AddNarInfoSignaturesParams) error {
	for _, v := range arg.Signature {
		err := w.adapter.AddNarInfoSignature(ctx, mysqldb.AddNarInfoSignatureParams{
			NarInfoID: arg.NarInfoID,
			Signature: v,
		})
		if err != nil {
			if IsDuplicateKeyError(err) {
				continue
			}
			return err
		}
	}
	return nil
}

func (w *mysqlWrapper) CreateConfig(ctx context.Context, arg CreateConfigParams) (Config, error) {
	// MySQL does not support RETURNING for INSERTs.
	// We insert, get LastInsertId, and then fetch the object.
	res, err := w.adapter.CreateConfig(ctx, mysqldb.CreateConfigParams(arg))
	if err != nil {
		return Config{}, err
	}

	id, err := res.LastInsertId()
	if err != nil {
		return Config{}, err
	}

	return w.GetConfigByID(ctx, id)
}

func (w *mysqlWrapper) CreateNarFile(ctx context.Context, arg CreateNarFileParams) (NarFile, error) {
	// MySQL does not support RETURNING for INSERTs.
	// We insert, get LastInsertId, and then fetch the object.
	res, err := w.adapter.CreateNarFile(ctx, mysqldb.CreateNarFileParams(arg))
	if err != nil {
		return NarFile{}, err
	}

	id, err := res.LastInsertId()
	if err != nil {
		return NarFile{}, err
	}

	return w.GetNarFileByID(ctx, id)
}

func (w *mysqlWrapper) CreateNarInfo(ctx context.Context, arg CreateNarInfoParams) (NarInfo, error) {
	// MySQL does not support RETURNING for INSERTs.
	// We insert, get LastInsertId, and then fetch the object.
	res, err := w.adapter.CreateNarInfo(ctx, mysqldb.CreateNarInfoParams(arg))
	if err != nil {
		return NarInfo{}, err
	}

	id, err := res.LastInsertId()
	if err != nil {
		return NarInfo{}, err
	}

	return w.GetNarInfoByID(ctx, id)
}

func (w *mysqlWrapper) DeleteNarFileByHash(ctx context.Context, hash string) (int64, error) {
	res, err := w.adapter.DeleteNarFileByHash(ctx, hash)
	if err != nil {
		// Primitive return (int64, string, etc)
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) DeleteNarFileByID(ctx context.Context, id int64) (int64, error) {
	res, err := w.adapter.DeleteNarFileByID(ctx, id)
	if err != nil {
		// Primitive return (int64, string, etc)
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) DeleteNarInfoByHash(ctx context.Context, hash string) (int64, error) {
	res, err := w.adapter.DeleteNarInfoByHash(ctx, hash)
	if err != nil {
		// Primitive return (int64, string, etc)
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) DeleteNarInfoByID(ctx context.Context, id int64) (int64, error) {
	res, err := w.adapter.DeleteNarInfoByID(ctx, id)
	if err != nil {
		// Primitive return (int64, string, etc)
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) DeleteOrphanedNarFiles(ctx context.Context) (int64, error) {
	res, err := w.adapter.DeleteOrphanedNarFiles(ctx)
	if err != nil {
		// Primitive return (int64, string, etc)
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) DeleteOrphanedNarInfos(ctx context.Context) (int64, error) {
	res, err := w.adapter.DeleteOrphanedNarInfos(ctx)
	if err != nil {
		// Primitive return (int64, string, etc)
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) GetConfigByID(ctx context.Context, id int64) (Config, error) {
	res, err := w.adapter.GetConfigByID(ctx, id)
	if err != nil {
		return Config{}, err
	}

	// Convert Single Domain Struct

	return Config(res), nil
}

func (w *mysqlWrapper) GetConfigByKey(ctx context.Context, key string) (Config, error) {
	res, err := w.adapter.GetConfigByKey(ctx, key)
	if err != nil {
		return Config{}, err
	}

	// Convert Single Domain Struct

	return Config(res), nil
}

func (w *mysqlWrapper) GetLeastUsedNarFiles(ctx context.Context, fileSize uint64) ([]NarFile, error) {
	res, err := w.adapter.GetLeastUsedNarFiles(ctx, fileSize)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]NarFile, len(res))
	for i, v := range res {
		items[i] = NarFile(v)
	}

	return items, nil
}

func (w *mysqlWrapper) GetLeastUsedNarInfos(ctx context.Context, fileSize uint64) ([]NarInfo, error) {
	res, err := w.adapter.GetLeastUsedNarInfos(ctx, fileSize)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]NarInfo, len(res))
	for i, v := range res {
		items[i] = NarInfo(v)
	}

	return items, nil
}

func (w *mysqlWrapper) GetNarFileByHash(ctx context.Context, hash string) (NarFile, error) {
	res, err := w.adapter.GetNarFileByHash(ctx, hash)
	if err != nil {
		return NarFile{}, err
	}

	// Convert Single Domain Struct

	return NarFile(res), nil
}

func (w *mysqlWrapper) GetNarFileByID(ctx context.Context, id int64) (NarFile, error) {
	res, err := w.adapter.GetNarFileByID(ctx, id)
	if err != nil {
		return NarFile{}, err
	}

	// Convert Single Domain Struct

	return NarFile(res), nil
}

func (w *mysqlWrapper) GetNarFileByNarInfoID(ctx context.Context, narinfoID int64) (NarFile, error) {
	res, err := w.adapter.GetNarFileByNarInfoID(ctx, narinfoID)
	if err != nil {
		return NarFile{}, err
	}

	// Convert Single Domain Struct

	return NarFile(res), nil
}

func (w *mysqlWrapper) GetNarFileCount(ctx context.Context) (int64, error) {
	res, err := w.adapter.GetNarFileCount(ctx)
	if err != nil {
		// Primitive return (int64, string, etc)
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) GetNarInfoByHash(ctx context.Context, hash string) (NarInfo, error) {
	res, err := w.adapter.GetNarInfoByHash(ctx, hash)
	if err != nil {
		return NarInfo{}, err
	}

	// Convert Single Domain Struct

	return NarInfo(res), nil
}

func (w *mysqlWrapper) GetNarInfoByID(ctx context.Context, id int64) (NarInfo, error) {
	res, err := w.adapter.GetNarInfoByID(ctx, id)
	if err != nil {
		return NarInfo{}, err
	}

	// Convert Single Domain Struct

	return NarInfo(res), nil
}

func (w *mysqlWrapper) GetNarInfoCount(ctx context.Context) (int64, error) {
	res, err := w.adapter.GetNarInfoCount(ctx)
	if err != nil {
		// Primitive return (int64, string, etc)
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) GetNarInfoHashesByNarFileID(ctx context.Context, narFileID int64) ([]string, error) {
	res, err := w.adapter.GetNarInfoHashesByNarFileID(ctx, narFileID)
	if err != nil {
		return nil, err
	}

	// Return Slice of Primitives (direct match)
	return res, nil
}

func (w *mysqlWrapper) GetNarInfoReferences(ctx context.Context, narinfoID int64) ([]string, error) {
	res, err := w.adapter.GetNarInfoReferences(ctx, narinfoID)
	if err != nil {
		return nil, err
	}

	// Return Slice of Primitives (direct match)
	return res, nil
}

func (w *mysqlWrapper) GetNarInfoSignatures(ctx context.Context, narinfoID int64) ([]string, error) {
	res, err := w.adapter.GetNarInfoSignatures(ctx, narinfoID)
	if err != nil {
		return nil, err
	}

	// Return Slice of Primitives (direct match)
	return res, nil
}

func (w *mysqlWrapper) GetNarTotalSize(ctx context.Context) (int64, error) {
	res, err := w.adapter.GetNarTotalSize(ctx)
	if err != nil {
		// Primitive return (int64, string, etc)
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) GetOrphanedNarFiles(ctx context.Context) ([]NarFile, error) {
	res, err := w.adapter.GetOrphanedNarFiles(ctx)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]NarFile, len(res))
	for i, v := range res {
		items[i] = NarFile(v)
	}

	return items, nil
}

func (w *mysqlWrapper) LinkNarInfoToNarFile(ctx context.Context, arg LinkNarInfoToNarFileParams) error {
	err := w.adapter.LinkNarInfoToNarFile(ctx, mysqldb.LinkNarInfoToNarFileParams(arg))
	if err != nil {
		return err
	}

	// No return value (void)
	return nil
}

func (w *mysqlWrapper) SetConfig(ctx context.Context, arg SetConfigParams) error {
	err := w.adapter.SetConfig(ctx, mysqldb.SetConfigParams(arg))
	if err != nil {
		return err
	}

	// No return value (void)
	return nil
}

func (w *mysqlWrapper) TouchNarFile(ctx context.Context, hash string) (int64, error) {
	res, err := w.adapter.TouchNarFile(ctx, hash)
	if err != nil {
		// Primitive return (int64, string, etc)
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) TouchNarInfo(ctx context.Context, hash string) (int64, error) {
	res, err := w.adapter.TouchNarInfo(ctx, hash)
	if err != nil {
		// Primitive return (int64, string, etc)
		return 0, err
	}

	// Return Primitive / *sql.DB / etc

	return res, nil
}

func (w *mysqlWrapper) WithTx(tx *sql.Tx) Querier {
	res := w.adapter.WithTx(tx)
	return &mysqlWrapper{adapter: res}
}

func (w *mysqlWrapper) DB() *sql.DB {
	return w.adapter.DB()
}
